[
  
  {
    "title": "BIT ECE实习之STM32开发",
    "url": "/posts/bit-ece-stm32/",
    "categories": "Coding",
    "tags": "c/c++, stm32, clion",
    "date": "2025-09-08 16:11:23 +0800",
    "content": "title: Text and Typography description: Examples of text, typography, math equations, diagrams, flowcharts, pictures, videos, and more. author: cotes date: 2019-08-08 11:33:00 +0800 categories: [Blogging, Demo] tags: [typography] pin: true math: true mermaid: true —  一、配置环境  1、IDE安装  我采用JetBrian开发的Clion进行开发，该软件对非商业用途免费，进入官网CLion Free for non-commercial use即可直接下载安装。  2、CubeMX与CubeCLT 我采用keysking开发的FubeMX协助进行环境安装。首先安装FubeMX，目录随意。安装完成后打开：    从此处先安装STM32CubeMX，也可以在官网进行下载。下载好安装包后按默认路径安装，一路确定即可。  之后继续从此处安装STM32CubeCLT，与上述操作一样地，下载好安装包后按默认路径安装，一路确定即可。  此处安装可以参考爽！手把手教你用CLion开发STM32【大人，时代变啦！！！】，只需参考CubeMX与CubeCLT安装部分即可。  3、OpenOCD安装 OpenOCD则在官网Download OpenOCD for Windows下载并安装，同样下载好安装包后按默认路径安装，一路确定即可。  4、Clion配置  打开Clion：   点击设置（Settings）：   之后按照安装路径参考图片进行配置：   注意选择编译器时，使用arm-none-eabi-gcc.exe和，arm-none-eabi-g++.exe。  之后修改CMake配置：   然后记住安装上述三个工具的路径，配置嵌入式开发环境：   最后在高级设置中启用调试器：   此处参考文献：  爽！手把手教你用CLion开发STM32【大人，时代变啦！！！】 - bilibili  【教程】配置 CLion 优雅开发 STM32 - 略无慕艳意 - 博客园  但要注意，上述配置过程中会遇到一些问题，需要参考本文后续叠加起来综合使用。  二、新建项目：  首先在Clion中点击新建嵌入式的项目：   注意不要直接新建，先点击启动STM32CubeMX，然后点击Start My project from MCU：   由于学校下发的材料为基于STM32F103VET6的野火指南者开发板，输入芯片规格，选中芯片后点击Start Project：   按照如图方式选择调试模式，注意一定要选择Serial Wire：   选中后可以发现左侧GPIO标识变绿。最后设置项目名和工具链，注意工具链一定选择CMake：   最后点击右上角GENERATE CORE即可：  记住路径后关闭窗口，回到Clion，将路径输入，可以发现此时可以创建项目了：   配置好Debug和Release两个CMake工具：   在此处点编辑配置：   进行OpenOCD配置：   注意此处要自己在任意位置新建一个.cfg文件，里面输入： # 野火FireDAP仿真器配置（基于CMSIS-DAP） source [find interface/cmsis-dap.cfg]  # 选择SWD接口 transport select swd  # 通信速率（1000kHz，兼容大多数情况） adapter speed 1000  # 目标芯片配置 source [find target/stm32f1x.cfg]  # STM32F103VET6 Flash配置（512KB） set FLASH_SIZE 0x80000  # 复位配置（关键：启用系统复位） reset_config srst_only srst_nogate  # 核心逻辑：利用before_init回调，在init执行前强制配置端口 # 解决CLion命令顺序导致的\"tcl port must be before init\"错误 proc before_init {} {     # 禁用tcl和gdb端口（使用正确的语法：tcl port 而非 tcl_port）     tcl port disabled     gdb port disabled }   最后点击确定即可。  代码在Core目录下，其中Src存放.c或.cpp文件，Inc存放.h文件：   此时如果连接开发板，点击绿色三角进行运行，若控制台显示如下良好，则表示配置完成。 [0mOpen On-Chip Debugger 0.12.0 (2024-09-16) . [https://github.com/sysprogs/openocd] Licensed under GNU GPL v2 libusb1 d52e355daa09f17ce64819122cb067b8a2ee0d4b For bug reports, read         http://openocd.org/doc/doxygen/bugs.html before_init DEPRECATED! use 'tcl port' not 'tcl_port' DEPRECATED! use 'gdb port', not 'gdb_port' DEPRECATED! use 'tcl port' not 'tcl_port' [0mInfo : CMSIS-DAP: SWD supported Info : CMSIS-DAP: Atomic commands supported Info : CMSIS-DAP: Test domain timer supported Info : CMSIS-DAP: FW Version = 2.0.0 Info : CMSIS-DAP: Interface Initialised (SWD) Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 1 nTRST = 0 nRESET = 1 Info : CMSIS-DAP: Interface ready Info : clock speed 1000 kHz Info : SWD DPIDR 0x1ba01477 Info : [stm32f1x.cpu] Cortex-M3 r1p1 processor detected Info : [stm32f1x.cpu] target has 6 breakpoints, 4 watchpoints Info : [stm32f1x.cpu] Examination succeed Info : [stm32f1x.cpu] gdb port disabled [stm32f1x.cpu] halted due to breakpoint, current mode: Thread xPSR: 0x01000000 pc: 0x0800219c msp: 0x20010000 ** Programming Started ** Info : device id = 0x10036414 Info : flash size = 512 KiB Warn : Adding extra erase range, 0x080031ac .. 0x080037ff ** Programming Finished ** shutdown command invoked    三、开发 本节中左右代码已上传至Github，仓库地址https://github.com/lamaper/BIT_ECE_STM32。  本节中所有作业来自上课课件，课件已经上传至BIT101仓库，本课程编号：100120050。  本节中采用的硬件是学校派发的野火指南者开发板，本文采用HAL库开发而不是标准库。硬件官方参考文档：[野火]STM32 HAL库开发实战指南-基于F103系列开发板—文档，其中给出了开发板外设地址：  /*片上外设基地址  */  #define PERIPH_BASE         ((unsigned int)0x40000000)   /*总线基地址，GPIO都挂载到APB2上 */  #define APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)   /*GPIOB外设基地址*/  #define GPIOA_BASE          (APB2PERIPH_BASE + 0x0800)   /* GPIOB寄存器地址,强制转换成指针 */  #define GPIOA_CRL           *(unsigned int*)(GPIOA_BASE+0x00)  #define GPIOA_CRH           *(unsigned int*)(GPIOA_BASE+0x04)  #define GPIOA_IDR           *(unsigned int*)(GPIOA_BASE+0x08)  #define GPIOA_ODR           *(unsigned int*)(GPIOA_BASE+0x0C)  #define GPIOA_BSRR          *(unsigned int*)(GPIOA_BASE+0x10)  #define GPIOA_BRR           *(unsigned int*)(GPIOA_BASE+0x14)  #define GPIOA_LCKR          *(unsigned int*)(GPIOA_BASE+0x18)   /*RCC外设基地址*/  #define RCC_BASE           (AHBPERIPH_BASE + 0x1000)  /*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/  #define RCC_APB2ENR        *(unsigned int*)(RCC_BASE+0x18)  作业-寄存器亮灯 作业内容：使用相应软件操作STM32开发板，用GPIO控制LED发光，用寄存器方式，分别地发射绿光、蓝光，用寄存器方式，控制LED发射黄光、紫光、白光，在黄、紫、白光中任选一种，提交工程压缩包。  首先查询官方操作手册，获取不同颜色LED灯的针脚信息以操作其发出不同颜色的光，创建文件led.h用于记录宏，之后创建LED控制宏以确保LED正常亮灭、定义一些快速操作的宏，方便后面快速调用颜色： #ifndef __LED_H #define __LED_H /**  * @author lamaper(Guo Jun Qi 1120241725)  */  #include \"main.h\"  /* ---------- LED引脚与时钟定义 ---------- */ // 红色LED（LED1） #define LED1_GPIO_PORT    GPIOB #define LED1_GPIO_PIN     GPIO_PIN_5 #define LED1_CLK_ENABLE() __HAL_RCC_GPIOB_CLK_ENABLE()  // 绿色LED（LED2） #define LED2_GPIO_PORT    GPIOB #define LED2_GPIO_PIN     GPIO_PIN_0 #define LED2_CLK_ENABLE() __HAL_RCC_GPIOB_CLK_ENABLE()  // 蓝色LED（LED3） #define LED3_GPIO_PORT    GPIOB #define LED3_GPIO_PIN     GPIO_PIN_1 #define LED3_CLK_ENABLE() __HAL_RCC_GPIOB_CLK_ENABLE()   /* ---------- LED控制宏（低电平点亮） ---------- */ #define LED_ON  GPIO_PIN_RESET  // 低电平点亮 #define LED_OFF GPIO_PIN_SET    // 高电平熄灭  // 基础控制宏 #define LED1_SetState(state) HAL_GPIO_WritePin(LED1_GPIO_PORT, LED1_GPIO_PIN, (state)) #define LED2_SetState(state) HAL_GPIO_WritePin(LED2_GPIO_PORT, LED2_GPIO_PIN, (state)) #define LED3_SetState(state) HAL_GPIO_WritePin(LED3_GPIO_PORT, LED3_GPIO_PIN, (state))  // 快捷操作宏 #define LED1_On()  LED1_SetState(LED_ON) #define LED1_Off() LED1_SetState(LED_OFF) #define LED1_Toggle() HAL_GPIO_TogglePin(LED1_GPIO_PORT, LED1_GPIO_PIN)  #define LED2_On()  LED2_SetState(LED_ON) #define LED2_Off() LED2_SetState(LED_OFF) #define LED2_Toggle() HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_GPIO_PIN)  #define LED3_On()  LED3_SetState(LED_ON) #define LED3_Off() LED3_SetState(LED_OFF) #define LED3_Toggle() HAL_GPIO_TogglePin(LED3_GPIO_PORT, LED3_GPIO_PIN)  /* ---------- 组合颜色宏 ---------- */ #define LED_Red()    do { LED1_On();  LED2_Off(); LED3_Off(); } while(0) #define LED_Green()  do { LED1_Off(); LED2_On();  LED3_Off(); } while(0) #define LED_Blue()   do { LED1_Off(); LED2_Off(); LED3_On();  } while(0) #define LED_Yellow() do { LED1_On();  LED2_On();  LED3_Off(); } while(0) #define LED_Purple() do { LED1_On();  LED2_Off(); LED3_On();  } while(0) #define LED_Cyan()   do { LED1_Off(); LED2_On();  LED3_On();  } while(0) #define LED_White()  do { LED1_On();  LED2_On();  LED3_On();  } while(0) #define LED_RGBOff() do { LED1_Off(); LED2_Off(); LED3_Off(); } while(0)  /* ---------- 函数声明 ---------- */ void LED_Init(void);   #endif /* __LED_H */  在led.c中编辑初始化LED的函数： #include \"led.h\"  /**  * @author lamaper (Guo Jun Qi 1120241725)  * @brief 初始化LED对应的GPIO  * @note 配置为推挽输出、无上下拉、低速  */ void LED_Init(void) {     GPIO_InitTypeDef GPIO_InitStruct = {0};      // 使能GPIOB时钟     LED1_CLK_ENABLE();     LED2_CLK_ENABLE();     LED3_CLK_ENABLE();      // 配置GPIO为推挽输出     GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;     GPIO_InitStruct.Pull = GPIO_NOPULL;     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;      // 配置LED1引脚     GPIO_InitStruct.Pin = LED1_GPIO_PIN;     HAL_GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStruct);      // 配置LED2引脚     GPIO_InitStruct.Pin = LED2_GPIO_PIN;     HAL_GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStruct);      // 配置LED3引脚     GPIO_InitStruct.Pin = LED3_GPIO_PIN;     HAL_GPIO_Init(LED3_GPIO_PORT, &amp;GPIO_InitStruct);      // 初始状态：所有LED熄灭     LED_RGBOff(); }  之后就可以在main函数中配置基础逻辑了： void HW1_SpmLight(void)// 用寄存器的方式，分别地发射绿光、蓝光 {   LED_Green();  HAL_Delay(500);  // 绿灯亮500ms   LED_Blue();   HAL_Delay(500);  // 蓝灯亮500ms } void HW1_MixLight(void) // 用寄存器的方式，控制LED发射黄光、紫光、白光 {   LED_Yellow(); HAL_Delay(500);  // 黄灯亮500ms   LED_Purple(); HAL_Delay(500);  // 紫灯亮500ms   LED_White();  HAL_Delay(500);  // 白灯亮500ms } void HW1_Submit(void) // 选择黄光、紫光、白光的任意一种提交工程压缩包 {   LED_Yellow(); // 黄灯长亮 }  编译运行后可以看到结果：   作业-按键与亮灯 作业内容：使用相应软件操作STM32开发板，使得按KEY1，控制LED灯在“红光-绿光-蓝光-白光”四种方式之间切换按KEY2，控制LED灯熄灭。  首先查询官方操作手册，获取KEY1和KEY2的针脚信息以操作其发出不同颜色的光，创建文件key.h用于记录宏： #ifndef __KEY_H #define __KEY_H  #include \"main.h\"  /* 按键引脚定义（野火指南者开发板） */ // KEY1 -&gt; PC13 #define KEY1_GPIO_PORT    GPIOC #define KEY1_GPIO_PIN     GPIO_PIN_13 #define KEY1_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE()  // KEY2 -&gt; PA0 #define KEY2_GPIO_PORT    GPIOA #define KEY2_GPIO_PIN     GPIO_PIN_0 #define KEY2_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE()  /* 函数声明 */ void KEY_Init(void); uint8_t KEY_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);  #endif /* __KEY_H */  单片机中按键检测并没有被封装，因而需要我们自行实现按下的逻辑检测。按键机械触点断开、闭合时，由于触点的弹性作用，按键开关不会马上稳定接通或一下子断开，使用按键时会产生带波纹信号，需要用软件消抖处理滤波，不方便输入检测。    本此实验采用的野火STM32指南者开发板（STM32F103VET6）板所搭载的按键带硬件消抖功能，它利用电容充放电的延时，消除了波纹，从而简化软件的处理，软件只需要直接检测引脚的电平即可。    从按键的原理图可知，这些按键在没有被按下的时候，GPIO引脚的输入状态为低电平；当按键按下时，GPIO引脚的输入状态为高电平。只要我们检测引脚的输入电平，即可判断按键是否被按下。  基于此在后续创建key.c控制按键识别，其中KEY_Init函数用来初始化按键，用KEY_Scan函数检测按钮状态，虽然硬件自带抖动消除，但是这里为了练习，使用HAL库的延时函数： #include \"key.h\"  /**  * @brief 初始化按键GPIO  */ void KEY_Init(void) {     GPIO_InitTypeDef GPIO_InitStruct = {0};      // 使能按键对应GPIO时钟     KEY1_CLK_ENABLE();     KEY2_CLK_ENABLE();      // 配置KEY1（PA0，上拉输入）     GPIO_InitStruct.Pin = KEY1_GPIO_PIN;     GPIO_InitStruct.Mode = GPIO_MODE_INPUT;     GPIO_InitStruct.Pull = GPIO_PULLUP;  // 上拉输入，按键按下为低电平     HAL_GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);      // 配置KEY2（PC13，上拉输入）     GPIO_InitStruct.Pin = KEY2_GPIO_PIN;     GPIO_InitStruct.Mode = GPIO_MODE_INPUT;     GPIO_InitStruct.Pull = GPIO_PULLUP;  // 上拉输入，按键按下为低电平     HAL_GPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct); }  /**  * @brief 按键扫描（带消抖，使用HAL_Delay）  * @param GPIOx: 按键GPIO端口  * @param GPIO_Pin: 按键GPIO引脚  * @retval 1: 按键按下（已消抖），0: 未按下  */ uint8_t KEY_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {     static uint8_t key_up = 1;  // 按键松开标志      if (key_up &amp;&amp; (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_RESET))     {         HAL_Delay(20);  // 消抖延时（使用HAL库延迟）         if (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_RESET)         {             key_up = 0;  // 标记按键按下             return 1;    // 返回按下状态         }     }     else if (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_SET)     {         HAL_Delay(20);  // 消抖延时         if (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_SET)         {             key_up = 1;  // 标记按键松开         }     }     return 0;  // 未按下 }  之后就可以在main函数中配置基础逻辑了。 void HW2(void) {   if (mode == 0) {     LED_RGBOff();     mode += 1;   }   // 作业2：KEY1切换模式（红光→绿光→蓝光→白光循环）   if (KEY_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == 1)   {     current_mode++;     if (current_mode &gt;= 4)  // 超过白光模式(3)则回到红光(0)       current_mode = 0;      // 根据当前模式切换LED（直接使用led.h中的宏）     switch(current_mode)     {       case 0: LED_Red();HAL_Delay(200);    break;       case 1: LED_Green();HAL_Delay(200);  break;       case 2: LED_Blue();HAL_Delay(200);   break;       case 3: LED_White();HAL_Delay(200);  break;       default: LED_RGBOff();break;     }   }    // 作业2：KEY2熄灭LED   if (KEY_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == 1)   {     current_mode = 4;  // 标记为熄灭模式     LED_RGBOff();   }    HAL_Delay(10);  // 消抖延时 }   作业-蜂鸣器 作业内容：使用相应软件操作STM32开发板，写一个函数，使用SysTick方法，计时0.25s使蜂鸣器产生n次短鸣+1长鸣，n=mod(学号末位)+1短鸣的时间为0.25s，长鸣时间为1s，每次鸣响之间间隔1s蜂鸣响起的同时，红色LED灯同时亮起。  我的学号末尾是5，后面采用5。  首先查询官方操作手册，获取蜂鸣器的针脚信息，创建文件beep.h用于记录宏，通过查询该开发板的技术手册可以得知，这块开发板采用有源蜂鸣器。STM32 驱动蜂鸣器的核心原理，是通过GPIO 引脚输出控制信号，配合蜂鸣器自身的发声结构，最终将电信号转化为声音信号。对于有源蜂鸣器，其内部自带振荡电路且包含芯片，只需GPIO输出高低电平——通电响、断电停——即可使其发声。基于此，定义如下宏以方便开发： #ifndef __BEEP_H #define __BEEP_H  #include \"main.h\" #include \"led.h\" // 用于控制红色LED（LED1）  /* ---------- 蜂鸣器硬件配置 ---------- */ #define BEEP_GPIO_PORT        GPIOA                   /* 蜂鸣器GPIO端口 */ #define BEEP_GPIO_PIN         GPIO_PIN_8              /* 蜂鸣器GPIO引脚 */ #define BEEP_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE()  /* 蜂鸣器时钟使能 */  /* 蜂鸣器控制宏（高电平触发鸣响） */ #define BEEP_ON  GPIO_PIN_SET #define BEEP_OFF GPIO_PIN_RESET #define BEEP_SetState(state) HAL_GPIO_WritePin(BEEP_GPIO_PORT, BEEP_GPIO_PIN, (state)) #define BEEP_On()  BEEP_SetState(BEEP_ON) #define BEEP_Off() BEEP_SetState(BEEP_OFF)  /* 函数声明 */ void BEEP_Init(void);                    // 蜂鸣器GPIO初始化 void BEEP_AlarmWithLED(uint8_t n);       // 1次短鸣 + 1次长鸣（同步红色LED亮灭）  #endif /* __BEEP_H */   在beep.c中实现头文件中定义的函数。首先是初始化蜂鸣器的GPIO，最后实现蜂鸣器鸣叫函数：  #include \"beep.h\"  /* 蜂鸣器GPIO初始化：配置为推挽输出 */ void BEEP_Init(void) {     GPIO_InitTypeDef GPIO_InitStruct = {0};      /* 使能蜂鸣器GPIO时钟 */     BEEP_GPIO_CLK_ENABLE();      /* 配置蜂鸣器引脚为推挽输出 */     GPIO_InitStruct.Pin = BEEP_GPIO_PIN;     GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;   // 推挽输出     GPIO_InitStruct.Pull = GPIO_NOPULL;           // 无上下拉     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  // 低速     HAL_GPIO_Init(BEEP_GPIO_PORT, &amp;GPIO_InitStruct);      /* 初始状态：蜂鸣器关闭 */     BEEP_Off(); }  /* 蜂鸣器鸣响+LED同步逻辑：n次短鸣(0.25s) + 1次长鸣(1s) */ void BEEP_AlarmWithLED(uint8_t n) {     uint8_t i;      /* 计算n：n = mod(学号末位,5) + 1 →      * 我的学号末位为5，即n = 5%5 +1 = 1 */     n = (n % 5) + 1;      /* 执行n次“短鸣+间隔” */     for (i = 0; i &lt; n; i++)     {         BEEP_On();   // 蜂鸣器响         LED1_On();   // 红色LED亮         HAL_Delay(250);  // 短鸣持续0.25s          BEEP_Off();  // 蜂鸣器关         LED1_Off();  // 红色LED灭         HAL_Delay(1000); // 短鸣间隔1s     }      /* 执行1次“长鸣” */     BEEP_On();     LED1_On();     HAL_Delay(1000); // 长鸣持续1s      /* 结束后关闭蜂鸣器和LED */     BEEP_Off();     LED1_Off(); }   作业-串口通信 作业内容：使用相应软件操作STM32开发板，用直接配置串口的方式，向PC传输一句话在FLASH中存储一句话，并用DMA配置串口向PC传输。  串口通讯是一种设备间非常常用的串行通讯方式，因为它简单便捷，因此大部分电子设备都支持该通讯方式，电子工程师在调试设备时也经常使用该通讯方式输出调试信息。  USART（Universal Synchronous/Asynchronous Receiver/Transmitter）是 STM32 芯片里的一种串行通信外设。它的主要功能就是把数据（字节）转换成一位一位的电平信号，通过TX引脚发出去，或者从RX引脚接收一位一位的电平信号，再拼成字节给CPU。在本实验中，只用到USART1的异步模式，即串口通信。  基于上述原理，创建文件usart.h用于记录宏： // // Created by lamaper on 2025/9/2. //  #ifndef __USART_H #define __USART_H  #include \"stm32f1xx_hal.h\" #include \"stm32f1xx_hal_uart.h\" #include &lt;string.h&gt;  /* 外部句柄 */ extern UART_HandleTypeDef huart1; extern DMA_HandleTypeDef hdma_tx;  /* 初始化 */ void USART1_UART_Init(void);  /* 普通发送 */ void UART_SendString(char *str);  /* DMA 发送 */ void UART_SendString_DMA(char *str);  #endif /* __USART_H */   之后开始编写初始化usart函数，首先开启USART1、GPIOA、DMA1时钟,之后配置引脚，在STM32F103系列芯片中，统一规定了USART1的引脚是PA9（TX，发送）和PA10（RX，接收）。在此处设置TX为复用推挽，使其能输出波形；RX作为输入，设为上拉状态，记为空闲。然后配置通信格式。 // // Created by lamaper on 2025/9/2. //  #include \"usart.h\"  UART_HandleTypeDef huart1; DMA_HandleTypeDef hdma_tx;  void USART1_UART_Init(void) {     __HAL_RCC_USART1_CLK_ENABLE();     __HAL_RCC_GPIOA_CLK_ENABLE();     __HAL_RCC_DMA1_CLK_ENABLE();      /* PA9 = TX, PA10 = RX */     GPIO_InitTypeDef GPIO_InitStruct = {0};      GPIO_InitStruct.Pin = GPIO_PIN_9;     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;     HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);      GPIO_InitStruct.Pin = GPIO_PIN_10;     GPIO_InitStruct.Mode = GPIO_MODE_INPUT;     GPIO_InitStruct.Pull = GPIO_NOPULL;     HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);      /* USART1 配置: 115200 8N1 */     huart1.Instance = USART1;     huart1.Init.BaudRate = 115200;     huart1.Init.WordLength = UART_WORDLENGTH_8B;     huart1.Init.StopBits = UART_STOPBITS_1;     huart1.Init.Parity = UART_PARITY_NONE;     huart1.Init.Mode = UART_MODE_TX_RX;     huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;     huart1.Init.OverSampling = UART_OVERSAMPLING_16;     HAL_UART_Init(&amp;huart1);      /* DMA 配置: USART1_TX = DMA1_Channel4 */     hdma_tx.Instance = DMA1_Channel4;     hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;     hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE;     hdma_tx.Init.MemInc = DMA_MINC_ENABLE;     hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;     hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;     hdma_tx.Init.Mode = DMA_NORMAL;     hdma_tx.Init.Priority = DMA_PRIORITY_LOW;     HAL_DMA_Init(&amp;hdma_tx);      __HAL_LINKDMA(&amp;huart1, hdmatx, hdma_tx);      /* DMA NVIC */     HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 1, 0);     HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn); }  void UART_SendString(char *str) {     HAL_UART_Transmit(&amp;huart1, (uint8_t*)str, strlen(str), HAL_MAX_DELAY); }  void UART_SendString_DMA(char *str) {     HAL_UART_Transmit_DMA(&amp;huart1, (uint8_t*)str, strlen(str)); }    STM32F1 的主存储器是片上Flash，既用来存程序，也能存数据。其掉电不丢失，适合存储固定配置；Flash以页为单位擦除，不能只擦除一个字节；以半字，即16bit为最小写入单位，必须2字节对齐。如果要操作，首先要解锁Flash，然后擦除页使其恢复0xFF，之后逐字（半字）写入数据，最后锁上Flash。  在flash.h中声明两个函数负责读写，同时选一个安全带页地址，本文选择STM32F103VET6 最后2K的起始地址（0x0807F800U）： // // Created by lamaper on 2025/9/2. //  #ifndef __FLASH_H #define __FLASH_H  #include \"stm32f1xx_hal.h\" #include &lt;string.h&gt;  /* 选一个安全的页地址（比如最后一页） */ #define FLASH_PAGE_ADDR 0x0807F800U  // STM32F103VET6 最后 2K 的起始地址  void Flash_Write(uint32_t addr, uint8_t *data, uint16_t len); void Flash_Read(uint32_t addr, uint8_t *buf, uint16_t len);  #endif /* __FLASH_H */   在flash.c中实现他们： // // Created by lamaper on 2025/9/2. //  #include \"flash.h\"  void Flash_Write(uint32_t addr, uint8_t *data, uint16_t len) {     HAL_FLASH_Unlock();      /* 先擦除页（注意：Flash 必须先擦才能重新写） */     FLASH_EraseInitTypeDef erase = {0};     uint32_t pageError = 0;     erase.TypeErase = FLASH_TYPEERASE_PAGES;     erase.PageAddress = FLASH_PAGE_ADDR;     erase.NbPages = 1;     HAL_FLASHEx_Erase(&amp;erase, &amp;pageError);      /* 半字写入 */     for (uint16_t i = 0; i &lt; len; i += 2)     {         uint16_t halfword = data[i];         if (i + 1 &lt; len) halfword |= (data[i+1] &lt;&lt; 8);         HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, addr + i, halfword);     }      HAL_FLASH_Lock(); }  void Flash_Read(uint32_t addr, uint8_t *buf, uint16_t len) {     for (uint16_t i = 0; i &lt; len; i++)     {         buf[i] = *(volatile uint8_t*)(addr + i);     } }   之后就可以在main函数中配置基础逻辑了： void HW4(void) {   USART1_UART_Init();    /* 1. 普通发送 */   UART_SendString(\"Hello, I'm lamaper! This is UART direct send!\\r\\n\");    /* 2. Flash 存储一句话 */   char msg[] = \"Hello from Flash + DMA!\\r\\n\";   Flash_Write(FLASH_PAGE_ADDR, (uint8_t*)msg, strlen(msg)+1);    /* 3. 读回并用 DMA 发送 */   char buf[64];   Flash_Read(FLASH_PAGE_ADDR, (uint8_t*)buf, strlen(msg)+1);   UART_SendString_DMA(buf); }  此外，注意到电脑本身并没有串口监控程序，需要单另下载，因而在Microsoft Store中下载相关工具，启动串口监听，有如下结果：    作业-七彩灯 作业内容：使用相应软件操作STM32开发板，以TIM3输出PWM，控制全彩LED灯变换颜色以另一个TIM作为计数器，每1s产生1次中断以中断控制一个状态机，改变全彩灯的CCR达到效果：赤-橙-黄-绿-青-蓝-紫，七种颜色循环切换，每1s切换一个颜色。  PWM 是 Pulse Width Modulation（脉冲宽度调制）的缩写，是一种通过改变脉冲信号的高电平持续时间与周期的比例，来模拟信号效果的数字控制技术。STM32 的定时器，如TIM3，可硬件生成高精度 PWM 信号，无需 CPU 持续干预。对 LED 来说，在频率足够高的情况下，人眼会因为视觉暂留把高频闪烁看作持续的光。TIMx作为PWM的时基有频率公式： \\(f_{PWM} = \\frac{f_{TIMCLK}}{(PSC+1) \\times (ARR+1)}\\)  其中ARR为自动重装载寄存器，决定周期长度，即计数上限；PSC为预分频器，决定计数节拍变慢多少；CRR是捕获/比较寄存器，对应占空比。在STM32F103系列芯片中，TIM3有多个通道能做PWM，通过重映射可以把它们映射到开发板的引脚上： // // Created by lamaper on 2025/9/2. //  #ifndef __TIM_H #define __TIM_H  #include \"stm32f1xx_hal.h\"      // HAL 基础 #include \"stm32f1xx_hal_tim.h\"  // TIM HAL  /* 全局句柄（只声明） */ extern TIM_HandleTypeDef htim3; // PWM (RGB) extern TIM_HandleTypeDef htim4; // 1s 周期中断  /* 初始化 */ void TIM3_PWM_Init(uint16_t arr, uint16_t psc); void TIM4_1s_Init(uint16_t arr, uint16_t psc);  /* 设置 RGB 占空比：0~arr（arr=自动重装值） */ void LED_SetRGB(uint16_t r, uint16_t g, uint16_t b);  /* 作业5：七彩灯（1s 切换） */ void Rainbow_Init(void);  /* 作业6：四彩呼吸灯（周期 1.5s） */ void Breath_Init(void);  void LED_ChannelTest(void);  #endif  接下来实现切换颜色。这里应作业要求，使用另一个计时器，本文采用TIM4.切换颜色并不需要高频变换，最自然的办法是使用计时器做一个1Hz的软节拍，每1s产生一次更新中断。NVIC 开启 TIM4_IRQn，在TIM4_IRQHandler 里调用HAL_TIM_IRQHandler，最终会进入HAL_TIM_PeriodElapsedCallback。 IM_HandleTypeDef htim3; TIM_HandleTypeDef htim4;  #ifndef M_PI #define M_PI 3.14159265358979323846 #endif  typedef enum { MODE_NONE = 0, MODE_RAINBOW, MODE_BREATH } TimerMode_t; static TimerMode_t g_mode = MODE_NONE; / void TIM3_PWM_Init(uint16_t arr, uint16_t psc) {     __HAL_RCC_TIM3_CLK_ENABLE();     __HAL_RCC_GPIOB_CLK_ENABLE();     __HAL_RCC_AFIO_CLK_ENABLE();      /* TIM3 部分重映射: CH2-&gt;PB5, CH3-&gt;PB0, CH4-&gt;PB1 */     __HAL_AFIO_REMAP_TIM3_PARTIAL();      GPIO_InitTypeDef GPIO_InitStruct = {0};     GPIO_InitStruct.Mode  = GPIO_MODE_AF_PP;     GPIO_InitStruct.Pull  = GPIO_NOPULL;     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;      /* R/G/B 对应引脚 */     GPIO_InitStruct.Pin = GPIO_PIN_5; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); // CH2 → PB5 → R     GPIO_InitStruct.Pin = GPIO_PIN_0; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); // CH3 → PB0 → G     GPIO_InitStruct.Pin = GPIO_PIN_1; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); // CH4 → PB1 → B      /* TIM3 基本参数 */     htim3.Instance = TIM3;     htim3.Init.Prescaler         = psc;     htim3.Init.CounterMode       = TIM_COUNTERMODE_UP;     htim3.Init.Period            = arr;     htim3.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;     htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;     HAL_TIM_PWM_Init(&amp;htim3);      /* 三路 PWM 通道配置：有效低（低电平点亮，数值越大越亮） */     TIM_OC_InitTypeDef sOC = {0};     sOC.OCMode     = TIM_OCMODE_PWM1;     sOC.Pulse      = 0;     sOC.OCPolarity = TIM_OCPOLARITY_LOW;      // ★ 有效低     sOC.OCFastMode = TIM_OCFAST_DISABLE;      HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sOC, TIM_CHANNEL_2); // R     HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sOC, TIM_CHANNEL_3); // G     HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sOC, TIM_CHANNEL_4); // B      HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);     HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);     HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4); }  void TIM4_Base_Init(uint16_t arr, uint16_t psc) {     __HAL_RCC_TIM4_CLK_ENABLE();      htim4.Instance = TIM4;     htim4.Init.Prescaler         = psc;     htim4.Init.CounterMode       = TIM_COUNTERMODE_UP;     htim4.Init.Period            = arr;     htim4.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;     htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;     HAL_TIM_Base_Init(&amp;htim4);      HAL_TIM_Base_Start_IT(&amp;htim4);     HAL_NVIC_SetPriority(TIM4_IRQn, 1, 0);     HAL_NVIC_EnableIRQ(TIM4_IRQn); }  void LED_SetRGB(uint16_t r, uint16_t g, uint16_t b) {     const uint16_t ARR = __HAL_TIM_GET_AUTORELOAD(&amp;htim3);      if (r &gt; ARR) r = ARR;     if (g &gt; ARR) g = ARR;     if (b &gt; ARR) b = ARR;      __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, r); // R -&gt; PB5     __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, g); // G -&gt; PB0     __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_4, b); // B -&gt; PB1 }  /* ==========================================================================  * 作业5：七彩灯（1s 切换，红→橙→黄→绿→青→蓝→紫）  * ========================================================================== */ static uint8_t rainbow_state = 0;  void Rainbow_Init(void) {     TIM4_Base_Init(999, 7999);  // 1s 节拍     rainbow_state = 0;     g_mode = MODE_RAINBOW; }  static void Rainbow_Update(void) {     const uint16_t ARR = __HAL_TIM_GET_AUTORELOAD(&amp;htim3);      switch (rainbow_state)     {         case 0: LED_SetRGB(ARR,   0,   0); break;        // 红         case 1: LED_SetRGB(ARR, ARR/2, 0); break;        // 橙 = 红 + 半绿         case 2: LED_SetRGB(ARR, ARR,   0); break;        // 黄 = 红 + 绿         case 3: LED_SetRGB(  0, ARR,   0); break;        // 绿         case 4: LED_SetRGB(  0, ARR, ARR); break;        // 青 = 绿 + 蓝         case 5: LED_SetRGB(  0,   0, ARR); break;        // 蓝         case 6: LED_SetRGB(ARR,   0, ARR); break;        // 紫 = 红 + 蓝     }     rainbow_state = (rainbow_state + 1) % 7; }  之后进行编译和烧录即可。  作业-呼吸灯 作业内容：使用相应软件操作STM32开发板，产生4彩（红、绿、蓝、白）呼吸灯，呼吸周期为1.x秒（x为学号尾数），CCR更新周期不高于0.2s。  呼吸灯的核心是占空比的周期性变化。首先回顾PWM的内容。PWM 是 Pulse Width Modulation（脉冲宽度调制）的缩写，是一种通过改变脉冲信号的高电平持续时间与周期的比例，来模拟信号效果的数字控制技术。STM32 的定时器，如TIM3，可硬件生成高精度 PWM 信号，无需 CPU 持续干预。对 LED 来说，在频率足够高的情况下，人眼会因为视觉暂留把高频闪烁看作持续的光。TIMx作为PWM的时基有频率公式： \\(f_{PWM} = \\frac{f_{TIMCLK}}{(PSC+1) \\times (ARR+1)}\\)  其中ARR为自动重装载寄存器，决定周期长度，即计数上限；PSC为预分频器，决定计数节拍变慢多少；CRR是捕获/比较寄存器，对应占空比。因而只需让CCR随着时间先增再减就能实现呼吸效果。本文采用余弦函数产生更平滑的呼吸效果： \\(duty(t) = \\frac{1-\\cos{(\\frac{2\\pi t}{T}})}{2}\\)  其中duty∈[0,1]，T为呼吸周期。 之后设置两个计时器，按照作业5的形式定义TIM3和TIM4的行为，这里不再赘述。 最终在上一节代码之后追加： #define BREATH_PERIOD 1.5f #define BREATH_DT     0.1f  static uint16_t breath_step  = 0; static uint8_t  breath_color = 0;  void Breath_Init(void) {     TIM4_Base_Init(99, 7999);  // 0.1s 节拍     breath_step  = 0;     breath_color = 0;     g_mode = MODE_BREATH; }  static void Breath_Update(void) {     const uint16_t ARR = __HAL_TIM_GET_AUTORELOAD(&amp;htim3);     const uint16_t steps_per_cycle = (uint16_t)(BREATH_PERIOD / BREATH_DT); // 例如1.5/0.1=15      float x    = (float)breath_step / (float)steps_per_cycle;       // 0..1     float duty = (1.0f - cosf(2.0f * (float)M_PI * x)) * 0.5f;      // 余弦曲线 0..1     uint16_t v = (uint16_t)(duty * ARR);      switch (breath_color)     {         case 0: LED_SetRGB(v, 0, 0);           break;  // 红         case 1: LED_SetRGB(0, v, 0);           break;  // 绿         case 2: LED_SetRGB(0, 0, v);           break;  // 蓝         case 3: LED_SetRGB(v, v, v);           break;  // 白         default: break;     }      breath_step++;     if (breath_step &gt;= steps_per_cycle)     {         breath_step  = 0;         breath_color = (breath_color + 1) % 4; // 红→绿→蓝→白     } }"
  },
  
  {
    "title": "UCB CS61A学习笔记",
    "url": "/posts/CS61A/",
    "categories": "Coding",
    "tags": "computer science, algorithm, python",
    "date": "2025-06-30 18:45:00 +0800",
    "content": "CS61A学习笔记  写在前面  CS61A的全称是Structure and Interpretation of Computer Programs（计算机程序的构造和解释），以Python语言授课。其课程内容主要是以Python为例，介绍程序设计中的各种方法，从控制语句到基础算法再到宏等。  单从课程目录来看，这门课与BIT开设的《C语言程序设计》有很多相似之处，虽然语言不同，但是思想却一致，所以学习CS61A并不需要按部就班的听每一节课，选择性地跳过已经学过的内容是高效的做法。  课程教材开源，可以直接阅读：Composing Programs  对于我个人来说，长期受C/C++、Java等强类型语言影响，很不适应Python的各种语法，学习本科目侧重于了解Python语言和编程思路，因而笔记也有不同的侧重点。  Part1 Python  Lecture 1 Welcome  主要是引入，强调了“表达式”概念  Lecture 2 Functions  变量与赋值  一个很神奇的Python变量赋值方式  f = max #max is a function   之后可以通过f来使用max  f(10,20,30) #30,相当于max(10,20,30)   个人认为这里相当于函数指针传递：  int max(int a,int b,int c); int (*f)(int,int,int) = &amp;max;   Python的特殊语法  显然相对于C语言，Python在变量上更加灵活。  需要注意的是在如下Python语句中：  a = 1 b = 2 a, b = a+b, a   a 最终为3，b最终为1，这里逗号表达式是同时进行赋值操作，所以不能理解为：  a = a + b b = a   函数的返回值  C 语言借助void类型来显式表明函数无返回值，并且禁止把这类函数的调用结果用于赋值操作。而 Python 采用动态类型系统，不管函数是否有返回值都能进行赋值，没有返回值时就返回None。这体现了静态类型语言（C 语言）和动态类型语言（Python）在设计理念上的差异。  例如在一个C语言例子中：  #include &lt;stdio.h&gt;  void test(int a){ \tint b = a; \treturn; }  int main(){    \tint b = test(2); \tprintf(\"%d\",b); \treturn 0; }   尝试编译运行会得到如下报错：  main.c: In function ‘main’: main.c:12:13: error: void value not ignored as it ought to be    12 |     int b = test(2);       |             ^~~~   意味着编译器禁止了接收void类型函数返回值的行为。  而在python中，对于：  &gt;&gt;&gt; print(print(1),print(2))   会有如下结果：  1 2 None None   也就是说，Python的任意函数都有返回值，在没有显式写明返回值时，返回None。  需要注意的是None并不等同与NULL，None表示 “存在但无值”，可以参与逻辑判断如：  if a is None: #使用is进行身份判断   而NULL通常表示 “无效引用” 或 “未初始化”（如空指针、空引用），涉及内存/地址。  Lecture 3 Control  讲了一些Python的基本语法与解释器运行法则及其部分用法。  在Python中布尔值为False的有：False，0，''，None，其余为True。  Python中没有传统意义的for循环。  Lab 00: Getting Started  教你如何本地测评与上传代码，由于咱不是UCB的学生，所以也没有办法上传代码，这段跳过。  HW 01: Functions, Control, Higher-Order Functions  from operator import add, mul  def square(x):     return x * x  def identity(x):     return x  def triple(x):     return 3 * x  def increment(x):     return x + 1   from operator import add, sub  def a_plus_abs_b(a, b):     \"\"\"Return a+abs(b), but without calling abs.      &gt;&gt;&gt; a_plus_abs_b(2, 3)     5     &gt;&gt;&gt; a_plus_abs_b(2, -3)     5     &gt;&gt;&gt; a_plus_abs_b(-1, 4)     3     &gt;&gt;&gt; a_plus_abs_b(-1, -4)     3     \"\"\"     if b &lt; 0:         f = sub     else:         f = add     return f(a, b)  def a_plus_abs_b_syntax_check():     \"\"\"Check that you didn't change the return statement of a_plus_abs_b.      &gt;&gt;&gt; # You aren't expected to understand the code of this test.     &gt;&gt;&gt; import inspect, re     &gt;&gt;&gt; re.findall(r'^\\s*(return .*)', inspect.getsource(a_plus_abs_b), re.M)     ['return f(a, b)']     \"\"\"     # You don't need to edit this function. It's just here to check your work.   def hailstone(n):     \"\"\"Print the hailstone sequence starting at n and return its     length.      &gt;&gt;&gt; a = hailstone(10)     10     5     16     8     4     2     1     &gt;&gt;&gt; a     7     &gt;&gt;&gt; b = hailstone(1)     1     &gt;&gt;&gt; b     1     \"\"\"     \"*** YOUR CODE HERE ***\"     print(n)     if n % 2 == 0:         return hailstone(n // 2) + 1     elif n % 2 != 0:         if n == 1:             return 1         else:             return hailstone(3 * n + 1) + 1   def product(n, term):     \"\"\"Return the product of the first n terms in a sequence.      n: a positive integer     term: a function that takes an index as input and produces a term      &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3     6     &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5     120     &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2     36     &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2     14400     &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)     24     &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3     162     \"\"\"     \"*** YOUR CODE HERE ***\"     if n == 1:         return term(1)     else:         return term(n) * product(n - 1, term)    def make_repeater(f, n):     \"\"\"Returns the function that computes the nth application of f.      &gt;&gt;&gt; add_three = make_repeater(increment, 3)     &gt;&gt;&gt; add_three(5)     8     &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))     243     &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))     625     &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))     390625     \"\"\"     \"*** YOUR CODE HERE ***\"     def repeater(x):         if n == 0:             return x         else:             return make_repeater(f, n - 1)(f(x))     return repeater    Lecture 4 Higher-Order Functions  先讲了一些优先运算行为，比如在python中，函数的参数在传入前要依次进行运算等。该例子老师讲的很到位，不再赘述。  紧接着是高阶函数。实际上可以理解为Python的形式参数可以接收函数名并在函数内部调用函数；此外，Python允许嵌套函数。  例如：  def apply_twice(f, x):     return f(f(X))  def square(x):     return x * x  result = apply_twice(square, 2)   此时相当于：  result = square(square(2))   在C语言中可以尝试理解为：  int apply_twice(int (*f)(int), int x){     return f(f(x)); }  int square(int x){     return x * x; }  int main(){     result = apply_twice(square, 2);     return 0; }   其中，函数指针在C语言的声明方式为&lt;返回值类型&gt; (*指针名)(参数列表)  Lecture 5 Environments  Python的闭包  给到一个例子：  def make_adder(n):     def adder(k):         return n + k     return adder  add_three = make_adder(3) add_three(4)   这段 Python 代码展示了闭包（Closure）的概念，即在函数内部定义的子函数可以捕获并记住外部函数的局部变量（本例子中为n），在C++11中引入的lambda表达式与Python的闭包极为相似，若用C++转写这段代码，可以写为：  auto make_adder(int n){     return [n](int k){         return n + k;     }; }  int main(){     auto add_three = make_adder(3);     std::cout &lt;&lt; add_three(4) &lt;&lt; endl;     return 0; }   C++ 中的 lambda 表达式是 C++11 引入的一项重要特性，它允许你在代码中内联定义匿名函数对象，从而方便地实现闭包功能，其格式为[capture list](parameter list) -&gt; return type { function body }  capture list为捕获列表，意味lambda表达式可从外界获取的参数，可以为引用，也可以为值；  parameter list为形式参数列表；  -&gt; return type 为返回值类型，可以省略，由auto自动推断；  auto func = [](int x) { return x * 2; }; // 等价于以下类的实例： struct __lambda {     int operator()(int x) const { return x * 2; } }; auto func = __lambda{};   回到Python的例子，return adder相当于返回一个函数指针，如此便可以理解。  对于Python，它也有lambda表达式，形式较为简单：lambda &lt;参数列表&gt;: &lt;表达式&gt;，自动返回表达式的值，为匿名函数。需要注意的是，Python的lambda表达式没有C++的强大，仅能完成一些简单的表达式计算。  add = lambda a, b: a + b  # 等价于 def add(a, b): return a + b print(add(3, 4))  # 输出：7   Lab 01: Functions, Control  前两个讨论题主要是关于Python的Shell，print可以打印字符，直接运行函数也可以显示其返回值，这里不再赘述。  def falling(n, k):     \"\"\"Compute the falling factorial of n to depth k.      &gt;&gt;&gt; falling(6, 3)  # 6 * 5 * 4     120     &gt;&gt;&gt; falling(4, 3)  # 4 * 3 * 2     24     &gt;&gt;&gt; falling(4, 1)  # 4     4     &gt;&gt;&gt; falling(4, 0)     1     \"\"\"     \"*** YOUR CODE HERE ***\"     ans = 1     i, j = k, n     while(i &gt; 0):         ans *= j         j -= 1         i -= 1     return ans   def divisible_by_k(n, k):     \"\"\"     &gt;&gt;&gt; a = divisible_by_k(10, 2)  # 2, 4, 6, 8, and 10 are divisible by 2     2     4     6     8     10     &gt;&gt;&gt; a     5     &gt;&gt;&gt; b = divisible_by_k(3, 1)  # 1, 2, and 3 are divisible by 1     1     2     3     &gt;&gt;&gt; b     3     &gt;&gt;&gt; c = divisible_by_k(6, 7)  # There are no integers up to 6 that are divisible by 7     &gt;&gt;&gt; c     0     \"\"\"     \"*** YOUR CODE HERE ***\"     count = 0     i = 1     while(i &lt;= n):         if i % k == 0:             print(i)             count += 1         i += 1     return count   def double_eights(n):     \"\"\"Return true if n has two eights in a row.     &gt;&gt;&gt; double_eights(8)     False     &gt;&gt;&gt; double_eights(88)     True     &gt;&gt;&gt; double_eights(2882)     True     &gt;&gt;&gt; double_eights(880088)     True     &gt;&gt;&gt; double_eights(12345)     False     &gt;&gt;&gt; double_eights(80808080)     False     \"\"\"     \"*** YOUR CODE HERE ***\"     while(n &gt;= 10):         if n % 10 == 8 and (n // 10) % 10 == 8:             return True         n //= 10     return False   def two_of_three(i, j, k):     \"\"\"Return m*m + n*n, where m and n are the two smallest members of the     positive numbers i, j, and k.      &gt;&gt;&gt; two_of_three(1, 2, 3)     5     &gt;&gt;&gt; two_of_three(5, 3, 1)     10     &gt;&gt;&gt; two_of_three(10, 2, 8)     68     &gt;&gt;&gt; two_of_three(5, 5, 5)     50     \"\"\"     return min(i, j, k) ** 2 + max(min(i, j),min(j, k),min(i, k)) ** 2  def two_of_three_syntax_check():     \"\"\"Check that your two_of_three code consists of nothing but a return statement.      &gt;&gt;&gt; # You aren't expected to understand the code of this test.     &gt;&gt;&gt; import inspect, ast     &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(two_of_three)).body[0].body]     ['Expr', 'Return']     \"\"\"     # You don't need to edit this function. It's just here to check your work.   def middle(a, b, c):     \"\"\"Return the number among a, b, and c that is not the smallest or largest.     Assume a, b, and c are all different numbers.      &gt;&gt;&gt; middle(3, 5, 4)     4     &gt;&gt;&gt; middle(30, 5, 4)     5     &gt;&gt;&gt; middle(3, 5, 40)     5     &gt;&gt;&gt; middle(3, 5, 40)     5     &gt;&gt;&gt; middle(30, 5, 40)     30     \"\"\"     return max(min(a, b),min(b, c),min(a, c))   def largest_factor(n):     \"\"\"Return the largest factor of n that is smaller than n.      &gt;&gt;&gt; largest_factor(15) # factors are 1, 3, 5     5     &gt;&gt;&gt; largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40     40     &gt;&gt;&gt; largest_factor(13) # factors are 1, 13     1     \"\"\"     \"*** YOUR CODE HERE ***\"     for i in range(n - 1, 0, -1):         if n % i == 0:             return i     return 1  def multiple(a, b):     \"\"\"Return the smallest number n that is a multiple of both a and b.      &gt;&gt;&gt; multiple(3, 4)     12     &gt;&gt;&gt; multiple(14, 21)     42     \"\"\"     \"*** YOUR CODE HERE ***\"     def gcd(x, y):         while y:             x, y = y, x % y         return x     def lcm(x, y):         return (x * y) // gcd(x, y)     return lcm(a, b)   Lecture 6 Sound (Optional)  选修课，用python制作wav音频  Project 01: The Game of Hog     规则    在 Hog 游戏中，两名玩家轮流尝试成为第一个以至少 GOAL 总分结束回合的人，其中 GOAL 默认为 100。在每个回合中，当前玩家选择掷出一些骰子，最多 10 个。该玩家该回合的分数是骰子结果的总和。但是，掷出太多骰子的玩家会面临以下风险：         逢一判负：如果掷出的骰子中任何一个为 1，则当前玩家该回合得分为 1。(英文名：Sow Sad)     示例 1： 当前玩家掷出 7 个骰子，其中 5 个骰子的结果为 1。他们该回合得 1 分。     示例 2： 当前玩家掷出 4 个骰子，所有骰子的结果均为 3。由于未发生逢一判负，他们该回合得 12 分。       在正常的 Hog 游戏中，这些就是所有的规则。为了给游戏增添趣味，我们将加入一些特殊规则：         野猪乱斗：当玩家掷出零个骰子时，其得分为对手分数十位与自身分数个位之差的绝对值的三倍，或者 1 分，取两者中的较大值。(英文名：Boar Brawl) 个位数为最右边的数字，十位数为倒数第二位数字。如果玩家的分数是个位数（小于 10），则该玩家分数的十位数为 0。     示例 1：                当前玩家有 21 分，对手有 46 分，当前玩家选择不掷骰子。         对手分数的十位数为 4，当前玩家分数的个位数为 1。         因此，玩家获得 3 * abs(4 - 1) = 9 分。                 示例 2：                当前玩家有 45 分，对手有 52 分，当前玩家选择跳过掷骰子环节。         对手分数的十位数为 5，当前玩家分数的个位数为 5。         由于 3 * abs(5 - 5) = 0，因此玩家获得 1 分。                 示例 3：                当前玩家有 2 分，对手有 5 分，当前玩家选择掷出零个骰子。         对手分数的十位数为 0，当前玩家分数的个位数为 2。         因此，玩家获得 3 * abs(0 - 2) = 6 分。                 Sus Fuss。如果一个数字恰好有 3 个或 4 个因子（包括 1 和它本身），我们就称它为 sus，即满足“可疑”条件的数字。如果在掷骰子后，当前玩家的分数是一个 sus 数字，那么他们的分数会直接提升至下一个质数。     示例 1：                玩家有 14 分，掷出 2 个骰子，总共得到 7 分。他们的新分数将是 21，新分数 21 包含四个因子：1、3、7 和 21。因为 21 是 sus，所以玩家的分数增加到 23，即下一个质数。                 示例 2：                玩家有 63 分，掷出 5 个骰子，总共得到 1 分。他们的新分数将是 64，它有 7 个因子：1、2、4、8、16、32 和 64。因为 64 不是 sus，所以玩家的分数保持不变。                 示例 3：                玩家有 49 分，掷出 5 个骰子，总共得到 18 分。他们的新分数将是 67，这是一个质数，有 2 个因子：1 和 67。因为 67 不是 sus，所以玩家的分数保持不变。                  \"\"\"The Game of Hog.\"\"\" #./hog.py #author:lamaper  from dice import six_sided, make_test_dice from ucb import main, trace, interact  GOAL = 100  # The goal of Hog is to score 100 points.  ###################### # Phase 1: Simulator # ######################   def roll_dice(num_rolls, dice=six_sided):     \"\"\"Simulate rolling the DICE exactly NUM_ROLLS &gt; 0 times. Return the sum of     the outcomes unless any of the outcomes is 1. In that case, return 1.      num_rolls:  The number of dice rolls that will be made.     dice:       A function that simulates a single dice roll outcome. Defaults to the six sided dice.     \"\"\"     # These assert statements ensure that num_rolls is a positive integer.     assert type(num_rolls) == int, \"num_rolls must be an integer.\"     assert num_rolls &gt; 0, \"Must roll at least once.\"     # BEGIN PROBLEM 1     \"*** YOUR CODE HERE ***\"     i = 0     total = 0     while(i &lt; num_rolls):         roll = dice()         if roll == 1:             return 1         total += roll         i += 1     return total     # END PROBLEM 1   def boar_brawl(player_score, opponent_score):     \"\"\"Return the points scored when the current player rolls 0 dice according to Boar Brawl.      player_score:     The total score of the current player.     opponent_score:   The total score of the other player.      \"\"\"     # BEGIN PROBLEM 2     \"*** YOUR CODE HERE ***\"     a = player_score % 10     b = (opponent_score // 10) % 10     return max(3 * abs(a - b), 1)     # END PROBLEM 2   def take_turn(num_rolls, player_score, opponent_score, dice=six_sided):     \"\"\"Return the points scored on a turn rolling NUM_ROLLS dice when the     current player has PLAYER_SCORE points and the opponent has OPPONENT_SCORE points.      num_rolls:       The number of dice rolls that will be made.     player_score:    The total score of the current player.     opponent_score:  The total score of the other player.     dice:            A function that simulates a single dice roll outcome.     \"\"\"     # Leave these assert statements here; they help check for errors.     assert type(num_rolls) == int, \"num_rolls must be an integer.\"     assert num_rolls &gt;= 0, \"Cannot roll a negative number of dice in take_turn.\"     assert num_rolls &lt;= 10, \"Cannot roll more than 10 dice.\"     # BEGIN PROBLEM 3     \"*** YOUR CODE HERE ***\"     if num_rolls == 0:         return boar_brawl(player_score, opponent_score)     else:         return roll_dice(num_rolls, dice)     # END PROBLEM 3   def simple_update(num_rolls, player_score, opponent_score, dice=six_sided):     \"\"\"Return the total score of a player who starts their turn with     PLAYER_SCORE and then rolls NUM_ROLLS DICE, ignoring Sus Fuss.     \"\"\"     score = player_score + take_turn(num_rolls, player_score, opponent_score, dice)     return score   def is_prime(n):     \"\"\"Return whether N is prime.\"\"\"     if n == 1:         return False     k = 2     while k &lt; n:         if n % k == 0:             return False         k += 1     return True   def num_factors(n):     \"\"\"Return the number of factors of N, including 1 and N itself.\"\"\"     # BEGIN PROBLEM 4     \"*** YOUR CODE HERE ***\"     if n == 1:         return 1     if is_prime(n):         return 2     count = 0     for i in range(1, n + 1):         if n % i == 0:             count += 1     return count     # END PROBLEM 4   def sus_points(score):     \"\"\"Return the new score of a player taking into account the Sus Fuss rule.\"\"\"     # BEGIN PROBLEM 4     \"*** YOUR CODE HERE ***\"     sus = num_factors(score)     if sus == 3 or sus == 4:         i = score         while not is_prime(i):             i += 1         return i     else :         return score     # END PROBLEM 4   def sus_update(num_rolls, player_score, opponent_score, dice=six_sided):     \"\"\"Return the total score of a player who starts their turn with     PLAYER_SCORE and then rolls NUM_ROLLS DICE, *including* Sus Fuss.     \"\"\"     # BEGIN PROBLEM 4     \"*** YOUR CODE HERE ***\"     score = take_turn(num_rolls, player_score, opponent_score, dice)     return sus_points(player_score + score)     # END PROBLEM 4   def always_roll_5(score, opponent_score):     \"\"\"A strategy of always rolling 5 dice, regardless of the player's score or     the opponent's score.     \"\"\"     return 5   def play(strategy0, strategy1, update, score0=0, score1=0, dice=six_sided, goal=GOAL):     \"\"\"Simulate a game and return the final scores of both players, with     Player 0's score first and Player 1's score second.      E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in     which both players always choose to roll 5 dice on every turn and the Sus     Fuss rule is in effect.      A strategy function, such as always_roll_5, takes the current player's     score and their opponent's score and returns the number of dice the current     player chooses to roll.      An update function, such as sus_update or simple_update, takes the number     of dice to roll, the current player's score, the opponent's score, and the     dice function used to simulate rolling dice. It returns the updated score     of the current player after they take their turn.      strategy0: The strategy for player0.     strategy1: The strategy for player1.     update:    The update function (used for both players).     score0:    Starting score for Player 0     score1:    Starting score for Player 1     dice:      A function of zero arguments that simulates a dice roll.     goal:      The game ends and someone wins when this score is reached.     \"\"\"     who = 0  # Who is about to take a turn, 0 (first) or 1 (second)     # BEGIN PROBLEM 5     \"*** YOUR CODE HERE ***\"     while score0 &lt; goal and score1 &lt; goal:         if who == 0:             num_rolls = strategy0(score0, score1)             score0 = update(num_rolls, score0, score1, dice)             if score0 &gt;= goal:                 break             who = 1         else:             num_rolls = strategy1(score1, score0)             score1 = update(num_rolls, score1, score0, dice)             if score1 &gt;= goal:                 break             who = 0     # END PROBLEM 5     return score0, score1   ####################### # Phase 2: Strategies # #######################   def always_roll(n):     \"\"\"Return a player strategy that always rolls N dice.      A player strategy is a function that takes two total scores as arguments     (the current player's score, and the opponent's score), and returns a     number of dice that the current player will roll this turn.      &gt;&gt;&gt; strategy = always_roll(3)     &gt;&gt;&gt; strategy(0, 0)     3     &gt;&gt;&gt; strategy(99, 99)     3     \"\"\"     assert n &gt;= 0 and n &lt;= 10      # BEGIN PROBLEM 6     \"*** YOUR CODE HERE ***\"     def strategy(score, opponent_score):         \"\"\"Return the number of dice to roll.\"\"\"         return n     return strategy     # END PROBLEM 6   def catch_up(score, opponent_score):     \"\"\"A player strategy that always rolls 5 dice unless the opponent     has a higher score, in which case 6 dice are rolled.      &gt;&gt;&gt; catch_up(9, 4)     5     &gt;&gt;&gt; strategy(17, 18)     6     \"\"\"     if score &lt; opponent_score:         return 6  # Roll one more to catch up     else:         return 5   def is_always_roll(strategy, goal=GOAL):     \"\"\"Return whether STRATEGY always chooses the same number of dice to roll     for every possible combination of score and opponent_score     given a game that goes to GOAL points.      &gt;&gt;&gt; is_always_roll(always_roll_5)     True     &gt;&gt;&gt; is_always_roll(always_roll(3))     True     &gt;&gt;&gt; is_always_roll(catch_up)     False     \"\"\"     # BEGIN PROBLEM 7     \"*** YOUR CODE HERE ***\"     for score in range(goal):         for opponent_score in range(goal):             if strategy(score, opponent_score) != strategy(0, 0):                 return False     return True     # END PROBLEM 7   def make_averaged(original_function, times_called=1000):     \"\"\"Return a function that returns the average value of ORIGINAL_FUNCTION     called TIMES_CALLED times.      To implement this function, you will have to use *args syntax.      &gt;&gt;&gt; dice = make_test_dice(4, 2, 5, 1)     &gt;&gt;&gt; averaged_dice = make_averaged(roll_dice, 40)     &gt;&gt;&gt; averaged_dice(1, dice)  # The avg of 10 4's, 10 2's, 10 5's, and 10 1's     3.0     \"\"\"      # BEGIN PROBLEM 8     \"*** YOUR CODE HERE ***\"     def averaged_function(*args):         total = 0         for _ in range(times_called):             total += original_function(*args)         return total / times_called     return averaged_function      # END PROBLEM 8   def max_scoring_num_rolls(dice=six_sided, times_called=1000):     \"\"\"Return the number of dice (1 to 10) that gives the maximum average score for a turn.     Assume that the dice always return positive outcomes.      &gt;&gt;&gt; dice = make_test_dice(1, 6)     &gt;&gt;&gt; max_scoring_num_rolls(dice)     1     \"\"\"     # BEGIN PROBLEM 9     \"*** YOUR CODE HERE ***\"     max_score = 0     min_rolls = 11     for num_rolls in range(1, 11):         score = make_averaged(roll_dice, times_called)(num_rolls, dice)         if score &gt; max_score:             max_score = score             min_rolls = num_rolls         elif score == max_score:             min_rolls = min(min_rolls, num_rolls)     return min_rolls     # END PROBLEM 9   def winner(strategy0, strategy1):     \"\"\"Return 0 if strategy0 wins against strategy1, and 1 otherwise.\"\"\"     score0, score1 = play(strategy0, strategy1, sus_update)     if score0 &gt; score1:         return 0     else:         return 1   def average_win_rate(strategy, baseline=always_roll(6)):     \"\"\"Return the average win rate of STRATEGY against BASELINE. Averages the     winrate when starting the game as player 0 and as player 1.     \"\"\"     win_rate_as_player_0 = 1 - make_averaged(winner)(strategy, baseline)     win_rate_as_player_1 = make_averaged(winner)(baseline, strategy)      return (win_rate_as_player_0 + win_rate_as_player_1) / 2   def run_experiments():     \"\"\"Run a series of strategy experiments and report results.\"\"\"     six_sided_max = max_scoring_num_rolls(six_sided)     print(\"Max scoring num rolls for six-sided dice:\", six_sided_max)      print(\"always_roll(6) win rate:\", average_win_rate(always_roll(6)))  # near 0.5     print(\"catch_up win rate:\", average_win_rate(catch_up))     print(\"always_roll(3) win rate:\", average_win_rate(always_roll(3)))     print(\"always_roll(8) win rate:\", average_win_rate(always_roll(8)))      print(\"boar_strategy win rate:\", average_win_rate(boar_strategy))     print(\"sus_strategy win rate:\", average_win_rate(sus_strategy))     print(\"final_strategy win rate:\", average_win_rate(final_strategy))     \"*** You may add additional experiments as you wish ***\"     def boar_strategy(score, opponent_score, threshold=11, num_rolls=6):     \"\"\"This strategy returns 0 dice if Boar Brawl gives at least THRESHOLD     points, and returns NUM_ROLLS otherwise. Ignore the Sus Fuss rule.     \"\"\"     # BEGIN PROBLEM 10     if boar_brawl(score, opponent_score) &gt;= threshold:         return 0     else:         return num_rolls       # END PROBLEM 10   def sus_strategy(score, opponent_score, threshold=11, num_rolls=6):     \"\"\"This strategy returns 0 dice when rolling 0 increases the score by at least     THRESHOLD points, and returns NUM_ROLLS otherwise. Consider both the Boar Brawl and     Suss Fuss rules.\"\"\"     # BEGIN PROBLEM 11     if sus_points(score + boar_brawl(score, opponent_score)) - score &gt;= threshold:         return 0     else:         return num_rolls     # END PROBLEM 11   def final_strategy(score, opponent_score):     \"\"\"Write a brief description of your final strategy.      *** YOUR DESCRIPTION HERE ***     \"\"\"     # BEGIN PROBLEM 12     return 6  # Remove this line once implemented.     # END PROBLEM 12   ########################## # Command Line Interface # ##########################  # NOTE: The function in this section does not need to be changed. It uses # features of Python not yet covered in the course.   @main def run(*args):     \"\"\"Read in the command-line argument and calls corresponding functions.\"\"\"     import argparse      parser = argparse.ArgumentParser(description=\"Play Hog\")     parser.add_argument(         \"--run_experiments\", \"-r\", action=\"store_true\", help=\"Runs strategy experiments\"     )      args = parser.parse_args()      if args.run_experiments:         run_experiments()   一个简单的项目实现，主要难在语言不通，题设很巧妙，需要我们用到前六节课所学的知识。  最终python3 -i hog.py有如下测试结果：  &gt;&gt;&gt; run_experiments()  Max scoring num rolls for six-sided dice: 7 always_roll(6) win rate: 0.494 catch_up win rate: 0.5125 always_roll(3) win rate: 0.34850000000000003 always_roll(8) win rate: 0.4635 boar_strategy win rate: 0.6685000000000001 sus_strategy win rate: 0.6910000000000001 final_strategy win rate: 0.511   与题设在问题10的预期“You should find that running now shows the boar_strategy win rate for close to 66-67%.”  Lecture 7 Function Abstruction  函数抽象，主要是进一步介绍高阶函数与lambda表达式。  在课程结尾还讲了Error和Traceback  Lecture 8 Function Examples  Python修饰器  在 Python 中，装饰器（Decorator）是一种强大的语法糖，允许在不修改原有函数代码的情况下，增强或修改函数的行为。它们本质上是一个可调用对象（函数、类等），接受一个函数作为输入，并返回另一个函数。  下面是一个例子：  def trace(fn):     def traced(x):         print(\"Calling\",fn,\"on argument\",x)         return fn(x)     return traced  @trace def square(x):     return x * x   其中，被trace修饰的squre可以等价于：  square = trace(square)   相当于把函数squre作为参数传入trace。     trace函数接收原始的square函数作为参数fn。   trace内部定义了traced函数并返回它，这个traced函数会替代原始的square函数。   新的square实际上是trace返回的traced函数。   所以当调用square(5)时，参数5被传递给traced函数的x参数。  用C语言实现修饰器的效果则如下：  typedef int (*Function)(int);  int square(int x){     return x * x; }  Function trace(Function func){     static int traced(int x){         printf(\"Calling %p on argument %d\\n\", (void*)func, x);         return func(x);     }     return traced; }  int main(){     //@trace     Function decorated = trace(square);     printf(\"Result: %d\\n\",decorated(5));     return 0; }   Lecture 9 Recursion  递归，比较重要的章节，主要是思路，个人认为这里以Python的Environment来解释递归不如直接上树形结构来的直观。实际上下一节课（lecture 10）就是树形递归。  在Python中实现递归会比较方便，因为python提供了灵活的函数返回值，使我们可以返回若干不同类型的值，不同于C/C++，因而在写代码的时候会更简洁一点。  Lecture 10 Tree-Recursion  本节课在最后提到了用树形递归加速斐波那契数列问题，实际上这是一个子问题分解，也可以理解为一种特殊的动态规划。  传统的斐波那契直接遵循其递推关系描述：  def fib_recursive(n):     if n &lt;= 1:         return n     return fib_recursive(n-1) + fib_recursive(n-2)   我们会发现其存在严重的重复计算问题，利用树形递归的思想，可以加速算法的实现：  def fib_iterative(n):     if n &lt;= 1:         return n          a, b = 0, 1  # 初始化F(0)和F(1)     for _ in range(2, n+1):         c = a + b      # 计算F(i) = F(i-1) + F(i-2)         a, b = b, c    # 滑动窗口更新              return b   Lecture 11 Sequences  Python数据类型：List  列表（list）是有限长度的相同类型的数据的集合，可以类比其他语言的数组，但比它们更强大。  定义一个列表：  dist = [1,2,3]   与其他语言相似地，列表的可以被索引访问，索引从0开始，因而dist[0]=1，利用相应函数可以获取列表的的长度，len(dist)的值为3。  python允许多维数组，如：  &gt;&gt;&gt; pairs = [[10, 20], [30, 40]] &gt;&gt;&gt; pairs[1] [30, 40] &gt;&gt;&gt; pairs[1][0] 30   python为使用者提供了语法糖，如：  &gt;&gt;&gt; digits = [1, 8, 2, 8] &gt;&gt;&gt; [2, 7] + digits * 2 [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]   可以发现digits被复制为2份。  列表的语法糖可以快速生成符合要求的序列：  &gt;&gt;&gt; odds = [1,2,3,4,5,6,7,8,9,10] &gt;&gt;&gt; [x for x in odds if x % 2 == 0] [2,4,6,8,10]   for循环  python优化了for循环，如果需要对digits进行遍历，可以有如下操作：  for elem in digits:     print(elem)   可以认为elem为digits的元素，并随着每次循环elem自动向后改变，直到最后一个元素。  range(x,y)是一个python内置序列，可以理解为一个左闭右开区间，如：  sum = 0 for i in range(1,11):     sum += i   可以等价于 \\(i \\in [1,11) = [1,10]\\\\ sum = \\sum^{10}_{i=1}i\\) 但是要注意，in作为运算符，其表达式返回一个布尔类型的值，如1 in digist的返回值为Ture。  此外，:运算符也可作为区间，依然符合左闭右开法则，左端省略则认为从0开始，右端省略则认为到最后。如dist[1:3]表示为从元素1到元素2的子序列  Lecture 12 Containers  List相关的内联函数  使用sum(&lt;list&gt;)可以简单实现列表的加和。  如：  &gt;&gt;&gt; [2,3] + [4] [2,3,4] &gt;&gt;&gt; sum([2,3],[4]) [2,3,4]   String  exec()可接受string类型的参数并作为命令执行。  可以将String理解为特殊的列表。  字典（Dictionary）  在 Python 里，字典（dict）的功能和其他编程语言中的 Map（或者叫哈希表、关联数组）是类似的。它们都借助 键值对（key-value pairs） 来存储数据，而且键都是唯一的，如果重复赋值，后面的值会覆盖前面的值。其中键必须是可哈希（不可变）的类型，像字符串、数字、元组（元组里的元素也得是可哈希的）。Python 3.7之后字典会保持插入顺序，迭代时会按照键值对插入的顺序返回。  Lecture 13 Data Abstraction  数据抽象是一个方法论，核心是改变一个功能时不影响另一个功能。  Lecture 14 Trees  主要讲述用列表实现树这个数据结构。  def tree(root, branches=[]):     for branch in branches:         assert is_tree(branch)     return [root] + list(branches)  def root(tree):     return tree[0]  def branches(tree):     return tree[1:]  def is_tree(tree):     if type(tree) != list or len(tree) &lt; 1 :         return False     for branch in branches(tree):         if not is_tree(branch):             return False     return Ture  def is_leaf(tree):     return not branches(tree)    本节课很有用，建议重复学习。  Lecture 15 Mutability  对象（Objects)  本节课终于讲到了对象。面向对象思想深深影响了现代编程语言，个人认为用Java学习面向对象会强过任何语言，因为Java的强面向对象性可以使我们更深刻的理解其特点。  面向对象要求对象拥有属性和方法，大多数编程语言调用对象的属性与方法都会使用.；  但这里只是简单的提及，后面应该会细讲  元组（Tuples）  元组相当于一个逗号序列，但是不可变，这不同于列表。列表是可变的。  这里所说的元组不可变是指大小或者结构，即空间不变，而非值不变。  可变性  在 Python 中，参数传递的方式既不是单纯的值传递，也不是单纯的引用传递，而是采用共享传递（Call by Sharing），也被称作对象引用传递。下面详细解释：  共享传递的核心特点     变量是对象的引用：Python 里，变量存放的是对象的引用，并非对象本身。   参数传递时引用被复制：当把参数传递给函数时，实际上是将变量的引用复制给了函数参数。这就使得函数内部的参数和外部的变量指向同一个对象。   对象的可变性决定了修改行为：            对于可变对象（如列表、字典、集合），在函数内部对其进行修改，外部的原始对象也会受到影响。       对于不可变对象（如整数、字符串、元组），由于无法修改对象本身，在函数内部对参数进行重新赋值时，只是让参数指向了一个新对象，不会改变外部的原始对象。           Lecture 16 Iterators  迭代器（Iterator）  在 Python 中，迭代器（Iterator）是实现了迭代器协议的对象，它允许你逐个访问集合中的元素，而无需预先加载整个集合到内存中。这一特性使得 Python 能够高效处理大规模数据，也是 Python 中循环、生成器和许多内置函数的核心机制。  迭代器必须实现两个核心方法：     __iter__()：返回迭代器自身（self），用于在for循环等场景中获取迭代器。   __next__()：返回迭代器的下一个元素。当没有更多元素时，抛出StopIteration异常。   迭代器是一次性的，当next为None时结束迭代。  惰性计算（Lazy Evaluation）  在 Python 中，惰性计算（Lazy Evaluation） 是一种重要的编程策略，它允许程序在需要时才进行计算，而非提前计算所有结果。这一特性显著提升了内存效率和程序性能，尤其适用于处理大数据、无限序列或复杂计算。  许多Python的内置函数返回类型为迭代器：          map(func, iterable)：将函数应用到每个元素。      nums = [1, 2, 3] squares = map(lambda x: x**2, nums)  # 返回map对象（迭代器）                filter(predicate, iterable)：过滤符合条件的元素。      evens = filter(lambda x: x % 2 == 0, nums)  # 返回filter对象                zip(*iterables)：并行迭代多个序列。      names = ['Alice', 'Bob'] ages = [25, 30] zipped = zip(names, ages)  # 返回zip对象           此外， itertools模块也提供了多种惰性工具。  Lecture 17 Generators  生成器  在Python中，生成器（Generators） 是实现惰性计算的一种特殊工具，它允许你在需要时才生成数据，而非一次性计算并存储所有结果。这使得代码更高效、更节省内存，尤其适合处理大数据或无限序列。生成器是一种特殊的迭代器，它的创建方式更简洁：     生成器函数：使用yield关键字的函数。   生成器表达式：类似列表推导式，但用圆括号()。                  特性       普通函数       生成器函数                       执行方式       一次性执行完毕       可以暂停和恢复执行                 状态保存       不保存状态，每次调用重置       保存上一次暂停的状态                 返回值       return返回单个值       yield返回迭代器（生成器）                 内存占用       可能高（存储所有结果）       低（按需生成）           使用yield关键字定义，每次调用next()时恢复执行： def countdown(n):     while n &gt; 0:         yield n  # 暂停执行并返回当前值         n -= 1  # 创建生成器对象 c = countdown(3)  print(next(c))  # 3 print(next(c))  # 2 print(next(c))  # 1 print(next(c))  # StopIteration异常   执行流程：    调用生成器函数时，函数体不会立即执行，而是返回一个生成器对象。   每次调用next()时，函数恢复执行，直到遇到yield暂停。   状态（变量值）会被保存，下次调用next()时继续执行。   生成器表达式（Generator Expressions）语法类似列表推导式，但用圆括号：  # 列表推导式：立即生成列表 squares_list = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]  # 生成器表达式：返回生成器对象 squares_gen = (x**2 for x in range(5))   # 生成器对象  print(next(squares_gen))  # 0 print(next(squares_gen))  # 1   高级生成器特性 send()方法  向生成器内部发送值并恢复执行： def receiver():     while True:         item = yield  # 接收外部发送的值         print(f\"Received: {item}\")  r = receiver() next(r)  # 启动生成器，必须先调用一次 r.send(\"Hello\")  # 发送值并恢复执行 → 输出: Received: Hello r.send(\"World\")  # → 输出: Received: World   throw()和close()    throw()：向生成器抛出异常。   close()：终止生成器。     gen = (x for x in range(5)) print(next(gen))  # 0 gen.close() print(next(gen))  # StopIteration异常（生成器已关闭）           yield from（Python 3.3+） 委托子生成器： def sub_generator():     yield 1     yield 2  def main_generator():     yield from sub_generator()  # 委托子生成器  gen = main_generator() print(list(gen))  # [1, 2]   Lecture 18 Objects  面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它将数据（属性）和操作数据的方法（行为）封装在对象中，并通过类来定义对象的结构和行为。Python 是一门支持面向对象编程的语言，提供了类、继承、多态等核心特性。类是对象的蓝图，定义了对象的属性和方法。对象是类的实例，具有类定义的属性和方法。  在Python中：  class Students:     #属性     name = \"Jack\"     age = 18     #方法     def drink():         print(\"drinking!\")   在C++中：  class Students{     #属性 private:     string name;     int age;         #方法 public:     void drink(){         printf(\"drinking!\\n\");     } };   在Java中：  public class Students{     private String name;     private int age;          public void drink(){         System.out.println(\"drinking!\");     } }   Lecture 19 Attributes  当我们需要调用创建对象时：  stu = Students() #python   Students stu(); //c++   Students stu = new Students(); //Java   此后如果需要调用对象的属性，可使用.来操作即可。  构造器/构造函数  在python中，如果需要在创建对象时对对象的属性进行初始化，则需要用到内联函数__init__():  class Students:     #没有特殊的初始化属性     def __init__(self, name, age):         self.name = name         self.age = age    Tom = Student('Tom',18) print(Tom.name) #Tom   这里的self不是需要填写的形式参数，而是所有实例方法必须有的参数，指实例自己。  如果熟悉C/C++或Java的人会在这里感到迷惑，因为name和age并没有被显式地定义。事实上这在Python中是被允许的，但是在其它很多语言中是不被允许的，例如Java：  public class Students{     private String name;//显式地定义属性，相当于实例化前的self.name     private int age;          public Student(String name,int age){         this.name = name;         this.age = age;     } }  public class Main{     public static void main(String args[]){ //main函数         Students Tom = new Students(\"Tom\",18);         System.out.println(Tom.name);     } }   在Java中，初始化函数/构造函数被成为构造器，是一个不需要声明返回值的、和类名称相同的函数。this关键字类似于self，这里的this.age等于在前面声明的private int age，而age是形式参数中的age。  在C++中：  class Students{ private:     string name;     int age;  public:     Students(string _name,int _age){         name = _name;         age = _age;     }          ~Students(){         delete[] string;         delete age;     } };   初始化函数/构造函数被成为构造函数，是一个不需要声明返回值的、和类名称相同的函数，与其匹配的是析构函数，在删除对象时调用。  Lecture 20 Inheritance  继承，即子类继承父类的属性和方法，可扩展或修改父类行为。可以认为是父类的拓展。  在python中：  class Animal:     def speak(self):         return \"Generic sound\"     def drink(self):         return \"drink\"  class Cat(Animal):  # 继承自Animal     def speak(self):  # 方法重写         return \"Meow\"  cat = Cat() print(cat.speak())  # → \"Meow\" print(cat.drink())  # → \"drink\"   方法重写是指在子类中实现与父类同名的函数时，其功能会覆盖父类的功能，当你调用时，使用的是子类实现的功能。当子类没有实现时，依旧可以调用该功能，此时是父类实现的功能。  面向对象的核心奥义之一是：不要重复实现方法。这也是继承这一特性出现的原因。  Lecture 21 Representation  represent  在 Python 里，repr() 是一个内置函数，其作用是返回一个对象的字符串表示形式，并且这个字符串应当是可解析的，或者说能清晰展示对象内容。  这意味着使用repr()可以获取构造该对象的代码。  如：  import datetime  today = datetime.datetime.now()  print(str(today))   # 输出：2025-07-05 12:30:45.123456（便于用户阅读） print(repr(today))  # 输出：datetime.datetime(2025, 7, 5, 12, 30, 45, 123456)（便于开发者理解）   points = [Point(0, 0), Point(1, 1)] print(points)  # 输出：[Point(0, 0), Point(1, 1)]   在自定义类中，我们可以通过 __repr__() 方法来定义对象的 repr() 输出。按照惯例，这个方法返回的字符串格式应该是 ClassName(arg1, arg2, ...)：  class Point:     def __init__(self, x, y):         self.x = x         self.y = y          def __repr__(self):         return f'Point({self.x}, {self.y})'  p = Point(3, 4) print(repr(p))  # 输出：Point(3, 4)   格式化字符串  Python 3.6之后引入了全新的格式化字符串方法，也就是课程视频中提到的F-String。直接在大括号中输入表达式即可。  如：  name = \"David\" age = 40 print(f\"Hello, {name}! You are {age} years old.\") # 输出：Hello, David! You are 40 years old.  x = 10 y = 20 print(f\"The sum of {x} and {y} is {x + y}\") # 输出：The sum of 10 and 20 is 30  text = \"hello\" print(f\"Uppercase: {text.upper()}\") # 输出：Uppercase: HELLO  price = 9.99 print(f\"Price: ${price:.2f}\")  # 保留2位小数 # 输出：Price: $9.99  person = {\"name\": \"Eve\", \"age\": 28} print(f\"{person['name']} is {person['age']} years old\") # 输出：Eve is 28 years old   这与C语言的格式化字符串有些许不同：  char name[] = \"David\"; int age = 40; printf(\"Hello, %s! You are %d years old.\\n\",name,age);   魔术方法（Magic Methods）  在 Python 中，魔术方法（Magic Methods）也被称为特殊方法（Special Methods），是一类以双下划线 __ 开头和结尾的特殊方法。它们为类提供了丰富的内置功能，使得自定义类能够像内置类型一样进行各种操作（如加减乘除、迭代、比较等）。  初始化与销毁：    __init__(self, ...)类的构造函数，创建对象时自动调用。   __del__(self)对象被销毁时调用（垃圾回收前），常用于资源释放。   字符串表示：     __str__(self)返回用户友好的字符串表示，用于 print() 和 str()。   __repr__(self)返回开发者友好的字符串表示，用于调试和 repr()。   算术运算符：     __sub__：减法（-）   __mul__：乘法（*）   __truediv__：除法（/）   __floordiv__：整除（//）   __mod__：取模（%）   __pow__：幂运算（**）   还有很多其他的，这里不过多阐述。  Lecture 22 Composition  链表（LInked List）  链表在C语言中已经学过：  struct node{     int id;     node *next; }Node;  Node *phead = (*Node)malloc(sizeof(Node)); phead-&gt;id = -1; phead-&gt;next = NULL;  void add(){ \t... }   C++的STL（Standard TemplateLibrary，标准模版库）中已经实现好双端链表和单向链表：  #include &lt;iostream&gt; #include &lt;list&gt;  int main() {     std::list&lt;int&gt; myList;     myList.push_back(1);     // 尾部插入     myList.push_front(0);    // 头部插入          // 遍历链表     for (int num : myList) {         std::cout &lt;&lt; num &lt;&lt; \" \";     }          myList.pop_front();      // 删除头部元素     std::cout &lt;&lt; \"\\nSize: \" &lt;&lt; myList.size();  // 输出: 1     return 0; }   其中std::list为双向链表， std::forward_list为单向链表  。  Java 的标准库中提供了 java.util.LinkedList 类，它实现了双向链表的功能，并实现了 List 和 Deque 接口，如：  import java.util.LinkedList;  public class LinkedListExample {     public static void main(String[] args) {         // 创建链表         LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();                  // 添加元素         list.add(\"Apple\");         list.add(\"Banana\");         list.addFirst(\"Cherry\");                  // 遍历链表         for (String fruit : list) {             System.out.println(fruit);         }                  // 移除元素         list.removeFirst();                  // 获取链表大小         System.out.println(\"Size: \" + list.size());     } }   而Python中并没有内置的链表结构，意味着我们需要自己实现。在课程中，老师给到一个单端链表的实现：  class List:     def __init__(self,id,next = empty):         assert next is Link empty or isinstance(next, Link)         self.id = id         self.next = next        s = List(1, List(2, List(3)))   Lecture 23 Efficiency  简单介绍了时间复杂度、空间复杂度和记忆化。  如果要了解或者深入研究应当参考《数据结构与算法》这门课。  Lecture 24 Decomposition  模块化设计，现场实现了一个Restaurant例子。  Lecture 25 Data Examples  给到了迭代器、链表的例子，建议跟代码敲一遍。  Lecture 30 Calculator  异常与异常处理  异常在前文Lecture 7已有提过，主要是程序运行时产生的错误，常见的错误有：     SyntaxError：语法错误   TypeError：类型错误（如对非数字类型进行数学运算）   ValueError：值错误（如 int(\"abc\")）   IndexError：索引越界   KeyError：字典键不存在   FileNotFoundError：文件不存在   ZeroDivisionError：除零错误   在 Python 中，异常处理是一种捕获和响应程序运行时错误的机制。通过异常处理，程序可以在遇到错误时不会崩溃，而是执行特定的恢复或清理操作。 Python 异常处理的核心概念和用法有：  try-except 块  使用 try 块包裹可能出错的代码，except 块处理特定类型的异常，使用 except Exception as e 捕获所有异常，并通过变量 e 获取异常信息：  try:     result = 10 / 0  # 可能引发 ZeroDivisionError except ZeroDivisionError:     print(\"Error: 除数不能为零！\") #------------------------- try:     num = int(\"abc\")  # 可能引发 ValueError     result = 10 / num  # 可能引发 ZeroDivisionError except ValueError:     print(\"Error: 输入不是有效的整数！\") except ZeroDivisionError:     print(\"Error: 除数不能为零！\") #------------------------- try:     # 可能引发多种异常的代码     file = open(\"nonexistent.txt\", \"r\") except Exception as e:     print(f\"发生错误: {e}\")  # 输出具体错误信息   使用 traceback 模块获取异常的堆栈跟踪信息：  import traceback  try:     result = 10 / 0 except ZeroDivisionError as e:     traceback.print_exc()  # 打印完整的错误堆栈   else 块在 try 块没有引发异常时执行；而finally 块无论是否发生异常都会执行，常用于资源清理：  try:     result = 10 / 2 except ZeroDivisionError:     print(\"Error: 除数不能为零！\") else:     print(f\"结果: {result}\")  # 当没有异常时执行 finally:     print(\"over\")   使用 raise 手动触发异常：  def divide(a, b):     if b == 0:         raise ZeroDivisionError(\"除数不能为零！\")     return a / b  try:     result = divide(10, 0) except ZeroDivisionError as e:     print(e)  # 输出: 除数不能为零！   通过继承 Exception 类可以创建自定义异常：  class InvalidAgeError(Exception):     def __init__(self, message=\"年龄不能为负数！\"):         self.message = message         super().__init__(self.message)  def check_age(age):     if age &lt; 0:         raise InvalidAgeError()     print(f\"年龄有效: {age}\")  try:     check_age(-5) except InvalidAgeError as e:     print(e)  # 输出: 年龄不能为负数！   Part2 Scheme  Lecture 28 Scheme  26、27不存在，课程从28继续开始按顺序编号。  从本章开始介绍一门全新的编程语言：Scheme。Scheme是Lisp的方言，Scheme只重视括号，而不关注缩进和空格。  从本节课开始，我们需要用Python编写一个Scheme解释器，这是一项很有挑战性的工程。  Lecture 29 Scheme Lists  &lt;Scheme&gt;  Lecture 30 Calculator  &lt;Scheme&gt;  Lecture 31 Interpreter  从本节课开始，正式介绍Scheme语言及实现其解释器的各种前置知识，可以认为是《编译原理》的启蒙和初级教学，  Lecture 32 Tail Calls (Optional)  尾递归。  &lt;Scheme&gt;  Lecture 33 Programs as Data  &lt;Scheme&gt;  Lecture 34 Macros  &lt;Scheme&gt;  Porject 4 Scheme                 从节开始，进行最后一个项目的编写，可以在[Scheme       CS自学社区](http://www.learncs.site/docs/curriculum-resource/cs61a/cs61a_zh/project/scheme)查看中文版的任务。           项目中将要编辑的文件：     scheme_eval_apply.py：Scheme 表达式递归求值器   scheme_forms.py：特殊形式求值   scheme_classes.py：描述 Scheme 表达式的类   questions.scm：需要实现的 Scheme 过程   问题 1      def define(self, symbol, value):         \"\"\"Define Scheme SYMBOL to have VALUE.\"\"\"         # BEGIN PROBLEM 1         \"*** YOUR CODE HERE ***\"         self.bindings[symbol] = value         # END PROBLEM 1      def lookup(self, symbol):         \"\"\"Return the value bound to SYMBOL. Errors if SYMBOL is not found.\"\"\"         # BEGIN PROBLEM 1         \"*** YOUR CODE HERE ***\"         if symbol in self.bindings:             return self.bindings[symbol]         # END PROBLEM 1         raise SchemeError('unknown identifier: {0}'.format(symbol))   问题 2  def scheme_apply(procedure, args, env):     \"\"\"Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in     Frame ENV, the current environment.\"\"\"     validate_procedure(procedure)     if not isinstance(env, Frame):        assert False, \"Not a Frame: {}\".format(env)     if isinstance(procedure, BuiltinProcedure):         # BEGIN PROBLEM 2         \"*** YOUR CODE HERE ***\"         res = []         print(f\"args: {args}, args.first: {args.first}, args.rest: {args.rest}\")         while args is not nil:             res.append(args.first)             args = args.rest         if procedure.need_env:             res.append(env)             # END PROBLEM 2         try:             # BEGIN PROBLEM 2             \"*** YOUR CODE HERE ***\"             return procedure.py_func(*res)              # END PROBLEM 2         except TypeError as err:             raise SchemeError('incorrect number of arguments: {0}'.format(procedure))     elif isinstance(procedure, LambdaProcedure):         # BEGIN PROBLEM 9         \"*** YOUR CODE HERE ***\"         # END PROBLEM 9     elif isinstance(procedure, MuProcedure):         # BEGIN PROBLEM 11         \"*** YOUR CODE HERE ***\"         # END PROBLEM 11     else:         assert False, \"Unexpected procedure: {}\".format(procedure)   Python作为弱类型语言实在是令人抓狂，需要注意的是，args是一个Pair类型，可以在程序运行时发现，执行 print(f\"args: {args}, args.first: {args.first}, args.rest: {args.rest}\")时返回如下结果：  args: (2 2), args.first: 2, args.rest: (2)   这说明args和args.rest是相同类型，而args.first是数字类型。  问题 3  def scheme_eval(expr, env, _=None): # Optional third argument is ignored     \"\"\"Evaluate Scheme expression EXPR in Frame ENV.      &gt;&gt;&gt; expr = read_line('(+ 2 2)')     &gt;&gt;&gt; expr     Pair('+', Pair(2, Pair(2, nil)))     &gt;&gt;&gt; scheme_eval(expr, create_global_frame())     4     \"\"\"     print(f\"scheme_eval: {expr}, env: {env}\")     # Evaluate atoms     if scheme_symbolp(expr):         print(f\"  scheme_symbolp(expr), scheme_eval: {expr}, env: {env}, return value: {env.lookup(expr)}\")         return env.lookup(expr)              elif self_evaluating(expr):         print(f\"  self_evaluating(expr), scheme_eval: {expr}, return value: {expr}\")         return expr          # All non-atomic expressions are lists (combinations)     if not scheme_listp(expr):         print(f\"  not scheme_listp(expr), scheme_eval: {expr}, raise SchemeError\")         raise SchemeError('malformed list: {0}'.format(repl_str(expr)))     first, rest = expr.first, expr.rest     if scheme_symbolp(first) and first in scheme_forms.SPECIAL_FORMS:         print(f\"  scheme_symbolp(first) and first in scheme_forms.SPECIAL_FORMS, first: {first}, rest: {rest}, env: {env}, return value: {scheme_forms.SPECIAL_FORMS[first](rest, env)}\")         return scheme_forms.SPECIAL_FORMS[first](rest, env)     else:         # BEGIN PROBLEM 3         \"*** YOUR CODE HERE ***\"         print(f\"  expr: {expr}, first: {first}, rest: {rest}, env: {env}, processer: {scheme_eval(first, env)}\")         processer = scheme_eval(first, env)         args = rest.map(lambda x: scheme_eval(x, env))         return scheme_apply(processer, args, env)         # END PROBLEM 3   为了方便观察，我在代码中添加了print方便显示递归过程，有如下测试结果：  scm&gt; (+ 2 2) scheme_eval: (+ 2 2), env: &lt;Global Frame&gt; scheme_eval: +, env: &lt;Global Frame&gt;   scheme_symbolp(expr), scheme_eval: +, env: &lt;Global Frame&gt;, return value: #[+]   expr: (+ 2 2), first: +, rest: (2 2), env: &lt;Global Frame&gt;, processer: #[+] scheme_eval: +, env: &lt;Global Frame&gt;   scheme_symbolp(expr), scheme_eval: +, env: &lt;Global Frame&gt;, return value: #[+] scheme_eval: 2, env: &lt;Global Frame&gt;   self_evaluating(expr), scheme_eval: 2, return value: 2 scheme_eval: 2, env: &lt;Global Frame&gt;   self_evaluating(expr), scheme_eval: 2, return value: 2 args: (2 2), args.first: 2, args.rest: (2) 4   后记  proj写到这里暂时写不动了，不太适应这种弱类型语言，时间全都花费在找参数类型上，这违背了编程的初衷，等后期顿悟了再回来填空吧。  Part3 SQL  Lecture 35-39 SQL  SQL（Structured Query Language）是一种专门用于管理和操作关系型数据库的编程语言。  主要功能：     数据定义（DDL）：用于创建、修改和删除数据库对象，像表、视图、索引等。   数据操作（DML）：负责对数据进行插入、查询、更新和删除操作。   数据控制（DCL）：用于管理用户权限，例如授予或撤销权限。   事务控制（TCL）：对事务进行管理，包括提交或回滚事务。   基本语法规则：     不区分大小写：一般习惯将关键字大写，而表名和列名小写。   语句以分号结尾：在大多数数据库系统中，SQL 语句以分号作为结束标志。   注释：单行注释使用--，多行注释使用/* ... */。   Select语句  SELECT [expression] AS [name], ...;  -- 简单查询 SELECT * FROM students;  -- 带条件查询 SELECT name, age FROM students WHERE age &gt; 20;  -- 排序 SELECT * FROM students ORDER BY age DESC;  -- 去重 SELECT DISTINCT gender FROM students;  -- 分页 SELECT * FROM students LIMIT 10 OFFSET 20;  -- MySQL语法   还有很多SQL语句，不在这里过多展示，可以进行查询获取。"
  },
  
  {
    "title": "记一次ArcGIS学习与操作",
    "url": "/posts/arcgis/",
    "categories": "Blogs",
    "tags": "blogs, arcgis",
    "date": "2025-03-11 18:45:00 +0800",
    "content": "由于思政课需要我们制作一套关于第一次鸦片战争的地理GIS（其实是为了凑满平时分），我们选择了ArcGIS来完成这一项工作。  一、软件安装  在某宝通过神秘方法找到慈禧付费版ArcGIS Pro 3.4.2后，根据安装教程顺利进行安装。这个版本的ArcGIS有汉语版，十分优秀。  二、数据搜索  考虑到我们要制作的GIS是针对1840年的，现有地图显然不能支持我们完成这项任务。哈佛大学的CHGIS v6很好的解决了我们的问题，在其官方数据库下载v6_1820_pref_pgn_utf（市一级行政区边界），v6_1820_pref_pts_utf（市一级行政区中心），v6_1820_prov_pgn_utf（省一级行政区边界），然后将这些包导入到ArcGIS中即可。        接下来要将一些数据插入：  在右侧目录视图中，找到数据库目录，进入后发现一个xx.gdb，右键新建要素类，然后按照需求创建数据库的表头即可。  我选择了“点”类型，包含“名称”、“经度”、“纬度”、“时间”、“参战方”、“伤亡人数”、“历史影响”，“备注”来包含第一次鸦片战争相关的位置信息。"
  },
  
  {
    "title": "一些神奇的C语言题目",
    "url": "/posts/c-in-bit/",
    "categories": "Coding",
    "tags": "c/c++, algorithm",
    "date": "2025-02-27 23:30:42 +0800",
    "content": "今天做了做2024年春季学期的C语言期末题目，恐怖如斯。OI退役已经两年多，很多代码脑子里面有想法，就是写不出来，尤其是C++转向C后，用不了STL，实在是有点不知所措。这个第二题，一眼顶针鉴定为字典树，但实际上它的数据量很小，如果用map会很快解决，但是没有如果，这里用不了map，我只能苦逼的写字典树。  (题目)[https://lexue.bit.edu.cn/mod/programming/view.php?id=484192]  输入一篇文章，以空行结束，希望统计一下其中单词出现的次数。  所谓“单词”，是仅由大写字母和/或小写字母组成的连续子串，且不区分大小写。例如，about是一个单词，a_out会被认为是a和out两个单词，about和About会被认为是同一个单词。  输出时，每个不同的单词输出一行，包括单词（全小写）和出现次数，以空格分隔。优先输出出现次数多的单词；出现次数相同的，按字典序输出。  数据范围 文章中，每个单词不超过20个字符，每行不超过80个字符，有效行数不超过100行。  #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  #define MAX_WORD_LEN 20 #define MAX_LINE_LEN 80 #define MAX_WORD_COUNT 1000  #define lamaper 0  typedef struct TrieNode {     struct TrieNode* children[26];//有26个子节点，对应26个字母     int count; //一般为0，如果不为零就代表到这里截至有单词出现，那么这里的数字就是单词出现的次数 } TrieNode;  TrieNode* create_node() {     TrieNode* node = (TrieNode*)malloc(sizeof(TrieNode));//神奇的初始化，没有面向对象就少了很多爽点     for(int i = 0; i &lt; 26; i++){         node-&gt;children[i] = NULL;     }     node-&gt;count = 0;     return node; }  TrieNode* insert_char(TrieNode* current, char c) {     if('a' &lt;= c &amp;&amp; c &lt;= 'z'){//按照题目要求进行大小写切换         int index = c - 'a';//把字母变成数字索引         if(current-&gt;children[index] == NULL){             current-&gt;children[index] = create_node();         }         return current-&gt;children[index];     }else if ('A' &lt;= c &amp;&amp; c &lt;= 'Z'){         int index = tolower(c) - 'a';         if (current-&gt;children[index] == NULL) {             current-&gt;children[index] = create_node();         }         return current-&gt;children[index];     }     return NULL; }  typedef struct WordCount{//这个用来统计词语     char word[MAX_WORD_LEN + 1];     int count; }WordCount;  WordCount word_list[MAX_WORD_COUNT];  int word_count = 0;  void dfs(TrieNode* node, char* prefix, int len){//简单的树的前序遍历     if(node-&gt;count &gt; 0){//如果这里被截断了         strncpy(word_list[word_count].word, prefix, len);//把prefix复制到word_list[word_count].word中         word_list[word_count].word[len] = '\\0';//补加一个截断，养成好习惯         word_list[word_count].count = node-&gt;count;         word_count++;     }      for(int i = 0; i &lt; 26; i++){         if(node-&gt;children[i] != NULL){             prefix[len] = 'a' + i;//把字母加到prefix里面             prefix[len + 1] = '\\0';             dfs(node-&gt;children[i], prefix, len + 1);//len既可以理解为长度也可以理解为搜索的深度         }     } }  int compare(const void* a, const void* b){//这个是专门给qsort排序用的，qsort类似于STL的sort     WordCount* w1 = (WordCount*)a;     WordCount* w2 = (WordCount*)b;     if(w1-&gt;count != w2-&gt;count){         return w2-&gt;count - w1-&gt;count; // 出现次数多的排在前面     }else{         return strcmp(w1-&gt;word, w2-&gt;word);          //strcmp 是 C 标准库中的一个字符串比较函数，用于按字典顺序比较两个字符串     } }  signed main(){     TrieNode* root = create_node();     TrieNode* current = root;      char line[MAX_LINE_LEN + 1];       while(fgets(line, sizeof(line), stdin) != NULL){         int len = strlen(line);         if(len == 1 &amp;&amp; line[0] == '\\n'){              break;         }         for(int i = 0; i &lt; len; i++){             char c = line[i];             if(isalpha(c)){ //如果是字母                 current = insert_char(current, c);             }else{ //不是就退回根节点                 if(current != root){                      current-&gt;count++;                 }                 current = root;              }         }     }      if(current != root){         current-&gt;count++;     }      char prefix[MAX_WORD_LEN + 1];     prefix[0] = '\\0';     dfs(root, prefix, 0);      qsort(word_list, word_count, sizeof(WordCount), compare);      for(int i = 0; i &lt; word_count; i++){         printf(\"%s %d\\n\", word_list[i].word, word_list[i].count);     }       return lamaper;//防伪 }"
  },
  
  {
    "title": "关于CHESS模型的一些学习",
    "url": "/posts/ai-sql/",
    "categories": "Blogs",
    "tags": "ai, chess",
    "date": "2025-02-19 16:24:23 +0800",
    "content": "CHESS的原理  CHESS论文：[2405.16755] CHESS: Contextual Harnessing for Efficient SQL Synthesis  CHESS 的实现过程  （1）Information Retriever (IR) - 信息检索器  从数据库模式中提取与问题相关的实体和上下文。     The Information Retriever (IR) agent aims to retrieve the relevant entities (values in the database) and context (schema descriptions provided in the database catalog). To achieve this, we present scalable and efficient methods using locality-sensitive hashing to retrieve database values from millions of rows, leveraging keyword detection, and vector databases to extract contextual information from database catalogs. Our approach utilizes both semantic and syntactic similarities between the database content and the user’s query to enhance the retrieval quality.   （2）Schema Selector (SS) - 模式选择器  进一步筛选出与问题最相关的表和列。     The goal of the Schema Selector (SS) agent is to reduce the schema size by selecting only the  necessary tables and columns required for generating the SQLquery. To achieve this, the SS agent is equipped with three tools, filter column, select tables, and select columns.   （3）Candidate Generator (CG) - 候选生成器  生成多个候选 SQL 查询。     The Candidate Generator (CG) is responsible for synthesizing SQL query that answers the question asked from the database. To accomplish this, the CG agent first calls the generate candidate query tool to generate candidate queries. It then executes these candidates on the database, checks the result, and identifies any faulty queries (those containing syntactic errors or empty result). For each faulty candidate, the agent repeatedly attempts to revise the query, until the issue is resolved or a maximum number of allowed revisions is reached.   （4）Unit Tester (UT) - 单元测试器  功能：通过自然语言单元测试评估生成的 SQL 查询。     The Unit Tester (UT) agent is responsible for selecting the most accurate SQL query from the pool of candidates generated by the CG agent. UT identifies the best candidate by 1) generating multiple unit tests that highlight differences between the candidate queries and 2) evaluating the candidates against these unit tests. It then assigns a score to each query based on the number of unit tests it passes, selecting the top-scoring candidate as the final SQL query for the given question.   实例分析  以california school 0为例，在bird测试集中:  {     \"question_id\": 0,     \"db_id\": \"california_schools\",     \"question\": \"What is the highest eligible free rate for K-12 students in the schools in Alameda County?\",     \"evidence\": \"Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`\",     \"SQL\": \"SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1\",     \"difficulty\": \"simple\"   },      “question_id”是测试集问题编号，该测试集一共有1534个问题   “db_id”是数据库名称   “evidence”是给AI的提示，用于辅助生成结果   “SQL”是标准查询语句，用于获取正确的查询结果   “difficulty”是BIRD给出的问题难度评级，”simple”&lt;”moderate”&lt;”challenging”   通过california_school_0.json与california_school_0.log逐级分析：  首先用户给出提示词，在log中有记录：  ############################## Human at step revise_sql ##############################  Objective: Your objective is to make sure a query follows the database admin instructions and use the correct conditions.  Database Schema:     CREATE TABLE frpm ( \tCDSCode TEXT not null primary key, \t`Academic Year` TEXT null, \t`County Code` TEXT null, \t`District Code` INTEGER null, \t`School Code` TEXT null, \t`County Name` TEXT null, -- examples: `Alameda` \t`District Name` TEXT null, \t`School Name` TEXT null, -- examples: `Alameda County Community`, `Alameda High` \t`District Type` TEXT null, \t`School Type` TEXT null, \t`Educational Option Type` TEXT null, \t`NSLP Provision Status` TEXT null, \t`Charter School (Y/N)` INTEGER null, \t`Charter School Number` TEXT null, \t`Charter Funding Type` TEXT null, \tIRC INTEGER null, \t`Low Grade` TEXT null, \t`High Grade` TEXT null, \t`Enrollment (K-12)` REAL null, -- description: Enrollment (K-12) \t`Free Meal Count (K-12)` REAL null, -- description: Free Meal Count (K-12) \t`Percent (%) Eligible Free (K-12)` REAL null, \t`FRPM Count (K-12)` REAL null, -- description: Free or Reduced Price Meal Count (K-12) \t`Percent (%) Eligible FRPM (K-12)` REAL null, \t`Enrollment (Ages 5-17)` REAL null, -- description: Enrollment (Ages 5-17) \t`Free Meal Count (Ages 5-17)` REAL null, -- description: Free Meal Count (Ages 5-17) \t`Percent (%) Eligible Free (Ages 5-17)` REAL null, \t`FRPM Count (Ages 5-17)` REAL null, \t`Percent (%) Eligible FRPM (Ages 5-17)` REAL null, \t`2013-14 CALPADS Fall 1 Certification Status` INTEGER null, \tforeign key (CDSCode) references schools (CDSCode), );  CREATE TABLE satscores ( \tcds TEXT not null primary key, \trtype TEXT not null, \tsname TEXT null, -- examples: `Alameda High` \tdname TEXT null, -- examples: `Alameda Unified` \tcname TEXT null, -- examples: `Alameda` \tenroll12 INTEGER not null, \tNumTstTakr INTEGER not null, \tAvgScrRead INTEGER null, \tAvgScrMath INTEGER null, \tAvgScrWrite INTEGER null, \tNumGE1500 INTEGER null, \tforeign key (cds) references schools (CDSCode), );  CREATE TABLE schools ( \tCDSCode TEXT not null primary key, \tNCESDist TEXT null, \tNCESSchool TEXT null, \tStatusType TEXT not null, \tCounty TEXT not null, -- examples: `Alameda` \tDistrict TEXT not null, -- examples: `Alameda County Office of Education` \tSchool TEXT null, -- examples: `Alameda County Community`, `Alameda High` \tStreet TEXT null, \tStreetAbr TEXT null, \tCity TEXT null, -- examples: `Alameda` \tZip TEXT null, \tState TEXT null, \tMailStreet TEXT null, \tMailStrAbr TEXT null, \tMailCity TEXT null, -- examples: `Alameda` \tMailZip TEXT null, \tMailState TEXT null, \tPhone TEXT null, \tExt TEXT null, \tWebsite TEXT null, \tOpenDate DATE null, -- examples: `1997-09-01` \tClosedDate DATE null, -- examples: `1984-07-24` \tCharter INTEGER null, \tCharterNum TEXT null, \tFundingType TEXT null, \tDOC TEXT not null, \tDOCType TEXT not null, \tSOC TEXT null, \tSOCType TEXT null, \tEdOpsCode TEXT null, \tEdOpsName TEXT null, \tEILCode TEXT null, \tEILName TEXT null, \tGSoffered TEXT null, -- examples: `K-12` \tGSserved TEXT null, -- examples: `K-12` \tVirtual TEXT null, \tMagnet INTEGER null, \tLatitude REAL null, \tLongitude REAL null, \tAdmFName1 TEXT null, \tAdmLName1 TEXT null, -- examples: `Free` \tAdmEmail1 TEXT null, \tAdmFName2 TEXT null, \tAdmLName2 TEXT null, \tAdmEmail2 TEXT null, \tAdmFName3 TEXT null, \tAdmLName3 TEXT null, \tAdmEmail3 TEXT null, \tLastUpdate DATE not null, -- examples: `2015-07-01` );  Database admin instructions: 1. When you need to find the highest or lowest values based on a certain condition, using ORDER BY + LIMIT 1 is prefered over using MAX/MIN within sub queries. 2. If predicted query includes an ORDER BY clause to sort the results, you should only include the column(s) used for sorting in the SELECT clause if the question specifically ask for them. Otherwise, omit these columns from the SELECT. 3. If the question doesn't specify exactly which columns to select, between name column and id column, prefer to select id column. 4. Make sure you only output the information that is asked in the question. If the question asks for a specific column, make sure to only include that column in the SELECT clause, nothing more. 5. Predicted query should return all of the information asked in the question without any missing or extra information. 7. For key phrases mentioned in the question, we have provided the most similar values within the columns denoted by \"-- examples\" in front of the corresponding column names. This is a crucial hint indicating the correct columns to use for your SQL query. 8. No matter of how many things the question asks, you should only return one SQL query as the answer having all the information asked in the question, seperated by a comma. 9. Using || ' ' ||  to concatenate is string is banned and using that is punishable by death. Never concatenate columns in the SELECT clause. 10. If you are joining multiple tables, make sure to use alias names for the tables and use the alias names to reference the columns in the query. Use T1, T2, T3, ... as alias names. 11. If you are doing a logical operation on a column, such as mathematical operations and sorting, make sure to filter null values within those columns. 12. When ORDER BY is used, just include the column name in the ORDER BY in the SELECT clause when explicitly asked in the question. Otherwise, do not include the column name in the SELECT clause.   Value Alameda that you used in the query appears in the column City of table schools. Value Alameda that you used in the query appears in the column MailCity of table schools. Value Alameda that you used in the query appears in the column County of table schools. Value Alameda that you used in the query appears in the column cname of table satscores.    Question: What is the highest eligible free rate for K-12 students in the schools in Alameda County?  Hint: Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`  Predicted query: SELECT MAX(CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'   Query result: [(1.0,)]  Please respond with a JSON object structured as follows (if the sql query is correct, return the query as it is):  {     \"chain_of_thought_reasoning\": \"Your thought process on how you arrived at the solution. You don't need to explain the instructions that are satisfied.\",     \"revised_SQL\": \"Your revised SQL query.\" }  Take a deep breath and think step by step to find the correct sqlite SQL query. If you follow all the instructions and generate the correct query, I will give you 1 million dollars.   AI通过分析用户的要求，得到如下结果：  ############################## AI at step revise_sql ##############################  {     \"chain_of_thought_reasoning\": \"To find the highest eligible free rate for K-12 students in schools located in Alameda County, we need to calculate the ratio of `Free Meal Count (K-12)` to `Enrollment (K-12)` for each school and then determine the maximum value of this ratio. The database schema indicates that these fields are located in the `frpm` table, and the county information is stored in the `County Name` column. The query filters records where `County Name` is 'Alameda' to focus on schools in Alameda County. The calculation for the eligible free rate is performed by dividing `Free Meal Count (K-12)` by `Enrollment (K-12)`, and the maximum value of this calculation is obtained using the MAX function. The query correctly handles the division by casting `Free Meal Count (K-12)` to REAL to ensure accurate division results. The query also ensures that only the maximum value of the calculated ratio is returned, adhering to the instruction to output only the information asked in the question.\",     \"revised_SQL\": \"SELECT MAX(CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'\" }      To find the highest eligible free rate for K-12 students in schools located in Alameda County, we need to calculate the ratio of Free Meal Count (K-12) to Enrollment (K-12) for each school and then determine the maximum value of this ratio.    The database schema indicates that these fields are located in the frpm table, and the county information is stored in the County Name column.    The query filters records where County Name is ‘Alameda’ to focus on schools in Alameda County.    The calculation for the eligible free rate is performed by dividing Free Meal Count (K-12) by Enrollment (K-12), and the maximum value of this calculation is obtained using the MAX function.    The query correctly handles the division by casting Free Meal Count (K-12) to REAL to ensure accurate division results.    The query also ensures that only the maximum value of the calculated ratio is returned, adhering to the instruction to output only the information asked in the question.   AI给出的结果写入到了revised_SQL中：  SELECT MAX(CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'   同一个问题会被询问2-3次，之后程序对进行评判回答是否正确：  ############################## Admin at step Evaluation ##############################  {     \"node_type\": \"evaluate_sql\",     \"evaluation_for\": \"nl_to_sql\",     \"exec_res\": 1,     \"exec_err\": \"--\",     \"Question\": \"What is the highest eligible free rate for K-12 students in the schools in Alameda County?\",     \"Evidence\": \"Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`\",     \"GOLD_SQL\": \"SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1\",     \"PREDICTED_SQL\": \"SELECT MAX(CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) FROM frpm WHERE `County Name` = 'Alameda' \" }  ############################## Admin at step Evaluation ##############################  {     \"node_type\": \"evaluate_sql\",     \"evaluation_for\": \"revise_sql\",     \"exec_res\": 1,     \"exec_err\": \"--\",     \"Question\": \"What is the highest eligible free rate for K-12 students in the schools in Alameda County?\",     \"Evidence\": \"Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`\",     \"GOLD_SQL\": \"SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1\",     \"PREDICTED_SQL\": \"SELECT MAX(CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'\" }   其中：     “GOLD_SQL”是在BIRD数据集中出现的标准答案   “PREDICTED_SQL”是AI产生的答案   “exec_res”是判断结果，如果结果正确则返回1，错误则返回0   “exec_err”是产生错误的原因，如果结果正确则返回”–”   “evaluation_for”是状态，evaluation_for: nl_to_sql 表示当前评估的目标是检查自然语言到 SQL 转换的准确性；evaluation_for: revise_sql 表示当前评估的目标是检查对原始 SQL 查询的修正是否正确。   下面是一个出现错误但最后被修正的日志：  ############################## Admin at step Evaluation ##############################  {     \"node_type\": \"evaluate_sql\",     \"evaluation_for\": \"nl_to_sql\",     \"exec_res\": 0,     \"exec_err\": \"incorrect answer\",     \"Question\": \"Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.\",     \"Evidence\": \"Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`\",     \"GOLD_SQL\": \"SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3\",     \"PREDICTED_SQL\": \"SELECT T2.`Free Meal Count (Ages 5-17)` / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Educational Option Type` = 'Continuation School' AND T2.`Enrollment (Ages 5-17)` &gt; 0 ORDER BY T2.`Free Meal Count (Ages 5-17)` / T2.`Enrollment (Ages 5-17)` ASC LIMIT 3 \" }  ############################## Admin at step Evaluation ##############################  {     \"node_type\": \"evaluate_sql\",     \"evaluation_for\": \"revise_sql\",     \"exec_res\": 1,     \"exec_err\": \"--\",     \"Question\": \"Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.\",     \"Evidence\": \"Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`\",     \"GOLD_SQL\": \"SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3\",     \"PREDICTED_SQL\": \"SELECT T2.`Free Meal Count (Ages 5-17)` / T2.`Enrollment (Ages 5-17)` AS EligibleFreeRate FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.EdOpsName = 'Continuation School' AND T2.`Enrollment (Ages 5-17)` &gt; 0 AND T2.`Free Meal Count (Ages 5-17)` IS NOT NULL AND T2.`Enrollment (Ages 5-17)` IS NOT NULL ORDER BY EligibleFreeRate ASC LIMIT 3\" }   在所给的error_logs中，出错的回答日志被筛选出，可以通过检索chain_of_thought_reasoning查询思维链从而尝试找出失误的原因。  此外，论文从29页开始，给出了一些错误回答与错误原因：  failed_summary.json  CHESS项目给出了他们在运行BIRD测试集时产生的中间结果，存放在CHESS/results/chess_on_dev.zip at chess-v1 · ShayanTalaei/CHESS，经过合并，所有产生失误的数据被单独筛选出来，放入failed_summary.json中。  为了方便查找与定位，所有产生失误的数据都被添加了单独的标签failure_annotations，可以快速查找标签以定位问题产生的原因。  如：                  \"missing_table_status\": \"success\",                 \"missing_tables\": [],                 \"missing_column_status\": \"missing_column\",                 \"missing_columns\": [                     \"'schools'.'county'\"                 ],                 \"correct_columns\": {                     \"frpm\": [                         \"School Name\",                         \"cdscode\",                         \"High Grade\",                         \"Low Grade\"                     ],                     \"schools\": [                         \"cdscode\",                         \"county\"                     ]                 },                 \"failure_annotations\": [                     \"Field 'missing_column_status' failed with value: missing_column\"                 ]             },   产生了”missing_column”问题  又如：              {                 \"node_type\": \"nl_to_sql\",                 \"status\": \"error\",                 \"error\": \"&lt;class 'TypeError'&gt;: &lt;'NoneType' object is not subscriptable&gt;\",                 \"failure_annotations\": [                     \"Field 'status' failed with value: error\"                 ]             },   在”nl_to_sql”环节发生错误。"
  }
  
]

